((typeof self !== 'undefined' ? self : this)["webpackJsonp"] = (typeof self !== 'undefined' ? self : this)["webpackJsonp"] || []).push([[1],{

/***/ "./node_modules/vee-validate/dist/vee-validate.full.js":
/*!*************************************************************!*\
  !*** ./node_modules/vee-validate/dist/vee-validate.full.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n  * vee-validate v3.0.8\n  * (c) 2019 Abdelrahman Awad\n  * @license MIT\n  */\n(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.runtime.esm.js\")) :\n  undefined;\n}(this, function (exports, Vue) { 'use strict';\n\n  Vue = Vue && Vue.hasOwnProperty('default') ? Vue['default'] : Vue;\n\n  var code = \"en\";\n  var messages = {\n  \talpha: \"The {_field_} field may only contain alphabetic characters\",\n  \talpha_num: \"The {_field_} field may only contain alpha-numeric characters\",\n  \talpha_dash: \"The {_field_} field may contain alpha-numeric characters as well as dashes and underscores\",\n  \talpha_spaces: \"The {_field_} field may only contain alphabetic characters as well as spaces\",\n  \tbetween: \"The {_field_} field must be between {min} and {max}\",\n  \tconfirmed: \"The {_field_} field confirmation does not match\",\n  \tdigits: \"The {_field_} field must be numeric and exactly contain {length} digits\",\n  \tdimensions: \"The {_field_} field must be {width} pixels by {height} pixels\",\n  \temail: \"The {_field_} field must be a valid email\",\n  \texcluded: \"The {_field_} field is not a valid value\",\n  \text: \"The {_field_} field is not a valid file\",\n  \timage: \"The {_field_} field must be an image\",\n  \tinteger: \"The {_field_} field must be an integer\",\n  \tlength: \"The {_field_} field must be {length} long\",\n  \tmax_value: \"The {_field_} field must be {max} or less\",\n  \tmax: \"The {_field_} field may not be greater than {length} characters\",\n  \tmimes: \"The {_field_} field must have a valid file type\",\n  \tmin_value: \"The {_field_} field must be {min} or more\",\n  \tmin: \"The {_field_} field must be at least {length} characters\",\n  \tnumeric: \"The {_field_} field may only contain numeric characters\",\n  \toneOf: \"The {_field_} field is not a valid value\",\n  \tregex: \"The {_field_} field format is invalid\",\n  \trequired_if: \"The {_field_} field is required\",\n  \trequired: \"The {_field_} field is required\",\n  \tsize: \"The {_field_} field size must be less than {size}KB\"\n  };\n  var en = {\n  \tcode: code,\n  \tmessages: messages\n  };\n\n  /**\r\n   * Some Alpha Regex helpers.\r\n   * https://github.com/chriso/validator.js/blob/master/src/lib/alpha.js\r\n   */\r\n  var alpha = {\r\n      en: /^[A-Z]*$/i,\r\n      cs: /^[A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]*$/i,\r\n      da: /^[A-ZÆØÅ]*$/i,\r\n      de: /^[A-ZÄÖÜß]*$/i,\r\n      es: /^[A-ZÁÉÍÑÓÚÜ]*$/i,\r\n      fr: /^[A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]*$/i,\r\n      it: /^[A-Z\\xC0-\\xFF]*$/i,\r\n      lt: /^[A-ZĄČĘĖĮŠŲŪŽ]*$/i,\r\n      nl: /^[A-ZÉËÏÓÖÜ]*$/i,\r\n      hu: /^[A-ZÁÉÍÓÖŐÚÜŰ]*$/i,\r\n      pl: /^[A-ZĄĆĘŚŁŃÓŻŹ]*$/i,\r\n      pt: /^[A-ZÃÁÀÂÇÉÊÍÕÓÔÚÜ]*$/i,\r\n      ru: /^[А-ЯЁ]*$/i,\r\n      sk: /^[A-ZÁÄČĎÉÍĹĽŇÓŔŠŤÚÝŽ]*$/i,\r\n      sr: /^[A-ZČĆŽŠĐ]*$/i,\r\n      sv: /^[A-ZÅÄÖ]*$/i,\r\n      tr: /^[A-ZÇĞİıÖŞÜ]*$/i,\r\n      uk: /^[А-ЩЬЮЯЄІЇҐ]*$/i,\r\n      ar: /^[ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]*$/,\r\n      az: /^[A-ZÇƏĞİıÖŞÜ]*$/i\r\n  };\r\n  var alphaSpaces = {\r\n      en: /^[A-Z\\s]*$/i,\r\n      cs: /^[A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ\\s]*$/i,\r\n      da: /^[A-ZÆØÅ\\s]*$/i,\r\n      de: /^[A-ZÄÖÜß\\s]*$/i,\r\n      es: /^[A-ZÁÉÍÑÓÚÜ\\s]*$/i,\r\n      fr: /^[A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ\\s]*$/i,\r\n      it: /^[A-Z\\xC0-\\xFF\\s]*$/i,\r\n      lt: /^[A-ZĄČĘĖĮŠŲŪŽ\\s]*$/i,\r\n      nl: /^[A-ZÉËÏÓÖÜ\\s]*$/i,\r\n      hu: /^[A-ZÁÉÍÓÖŐÚÜŰ\\s]*$/i,\r\n      pl: /^[A-ZĄĆĘŚŁŃÓŻŹ\\s]*$/i,\r\n      pt: /^[A-ZÃÁÀÂÇÉÊÍÕÓÔÚÜ\\s]*$/i,\r\n      ru: /^[А-ЯЁ\\s]*$/i,\r\n      sk: /^[A-ZÁÄČĎÉÍĹĽŇÓŔŠŤÚÝŽ\\s]*$/i,\r\n      sr: /^[A-ZČĆŽŠĐ\\s]*$/i,\r\n      sv: /^[A-ZÅÄÖ\\s]*$/i,\r\n      tr: /^[A-ZÇĞİıÖŞÜ\\s]*$/i,\r\n      uk: /^[А-ЩЬЮЯЄІЇҐ\\s]*$/i,\r\n      ar: /^[ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ\\s]*$/,\r\n      az: /^[A-ZÇƏĞİıÖŞÜ\\s]*$/i\r\n  };\r\n  var alphanumeric = {\r\n      en: /^[0-9A-Z]*$/i,\r\n      cs: /^[0-9A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]*$/i,\r\n      da: /^[0-9A-ZÆØÅ]$/i,\r\n      de: /^[0-9A-ZÄÖÜß]*$/i,\r\n      es: /^[0-9A-ZÁÉÍÑÓÚÜ]*$/i,\r\n      fr: /^[0-9A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]*$/i,\r\n      it: /^[0-9A-Z\\xC0-\\xFF]*$/i,\r\n      lt: /^[0-9A-ZĄČĘĖĮŠŲŪŽ]*$/i,\r\n      hu: /^[0-9A-ZÁÉÍÓÖŐÚÜŰ]*$/i,\r\n      nl: /^[0-9A-ZÉËÏÓÖÜ]*$/i,\r\n      pl: /^[0-9A-ZĄĆĘŚŁŃÓŻŹ]*$/i,\r\n      pt: /^[0-9A-ZÃÁÀÂÇÉÊÍÕÓÔÚÜ]*$/i,\r\n      ru: /^[0-9А-ЯЁ]*$/i,\r\n      sk: /^[0-9A-ZÁÄČĎÉÍĹĽŇÓŔŠŤÚÝŽ]*$/i,\r\n      sr: /^[0-9A-ZČĆŽŠĐ]*$/i,\r\n      sv: /^[0-9A-ZÅÄÖ]*$/i,\r\n      tr: /^[0-9A-ZÇĞİıÖŞÜ]*$/i,\r\n      uk: /^[0-9А-ЩЬЮЯЄІЇҐ]*$/i,\r\n      ar: /^[٠١٢٣٤٥٦٧٨٩0-9ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]*$/,\r\n      az: /^[0-9A-ZÇƏĞİıÖŞÜ]*$/i\r\n  };\r\n  var alphaDash = {\r\n      en: /^[0-9A-Z_-]*$/i,\r\n      cs: /^[0-9A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ_-]*$/i,\r\n      da: /^[0-9A-ZÆØÅ_-]*$/i,\r\n      de: /^[0-9A-ZÄÖÜß_-]*$/i,\r\n      es: /^[0-9A-ZÁÉÍÑÓÚÜ_-]*$/i,\r\n      fr: /^[0-9A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ_-]*$/i,\r\n      it: /^[0-9A-Z\\xC0-\\xFF_-]*$/i,\r\n      lt: /^[0-9A-ZĄČĘĖĮŠŲŪŽ_-]*$/i,\r\n      nl: /^[0-9A-ZÉËÏÓÖÜ_-]*$/i,\r\n      hu: /^[0-9A-ZÁÉÍÓÖŐÚÜŰ_-]*$/i,\r\n      pl: /^[0-9A-ZĄĆĘŚŁŃÓŻŹ_-]*$/i,\r\n      pt: /^[0-9A-ZÃÁÀÂÇÉÊÍÕÓÔÚÜ_-]*$/i,\r\n      ru: /^[0-9А-ЯЁ_-]*$/i,\r\n      sk: /^[0-9A-ZÁÄČĎÉÍĹĽŇÓŔŠŤÚÝŽ_-]*$/i,\r\n      sr: /^[0-9A-ZČĆŽŠĐ_-]*$/i,\r\n      sv: /^[0-9A-ZÅÄÖ_-]*$/i,\r\n      tr: /^[0-9A-ZÇĞİıÖŞÜ_-]*$/i,\r\n      uk: /^[0-9А-ЩЬЮЯЄІЇҐ_-]*$/i,\r\n      ar: /^[٠١٢٣٤٥٦٧٨٩0-9ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ_-]*$/,\r\n      az: /^[0-9A-ZÇƏĞİıÖŞÜ_-]*$/i\r\n  };\n\n  var validate = function (value, _a) {\r\n      var _b = (_a === void 0 ? {} : _a).locale, locale = _b === void 0 ? '' : _b;\r\n      if (Array.isArray(value)) {\r\n          return value.every(function (val) { return validate(val, { locale: locale }); });\r\n      }\r\n      // Match at least one locale.\r\n      if (!locale) {\r\n          return Object.keys(alpha).some(function (loc) { return alpha[loc].test(value); });\r\n      }\r\n      return (alpha[locale] || alpha.en).test(value);\r\n  };\r\n  var params = [\r\n      {\r\n          name: 'locale'\r\n      }\r\n  ];\r\n  var alpha$1 = {\r\n      validate: validate,\r\n      params: params\r\n  };\n\n  var validate$1 = function (value, _a) {\r\n      var _b = (_a === void 0 ? {} : _a).locale, locale = _b === void 0 ? '' : _b;\r\n      if (Array.isArray(value)) {\r\n          return value.every(function (val) { return validate$1(val, { locale: locale }); });\r\n      }\r\n      // Match at least one locale.\r\n      if (!locale) {\r\n          return Object.keys(alphaDash).some(function (loc) { return alphaDash[loc].test(value); });\r\n      }\r\n      return (alphaDash[locale] || alphaDash.en).test(value);\r\n  };\r\n  var params$1 = [\r\n      {\r\n          name: 'locale'\r\n      }\r\n  ];\r\n  var alpha_dash = {\r\n      validate: validate$1,\r\n      params: params$1\r\n  };\n\n  var validate$2 = function (value, _a) {\r\n      var _b = (_a === void 0 ? {} : _a).locale, locale = _b === void 0 ? '' : _b;\r\n      if (Array.isArray(value)) {\r\n          return value.every(function (val) { return validate$2(val, { locale: locale }); });\r\n      }\r\n      // Match at least one locale.\r\n      if (!locale) {\r\n          return Object.keys(alphanumeric).some(function (loc) { return alphanumeric[loc].test(value); });\r\n      }\r\n      return (alphanumeric[locale] || alphanumeric.en).test(value);\r\n  };\r\n  var params$2 = [\r\n      {\r\n          name: 'locale'\r\n      }\r\n  ];\r\n  var alpha_num = {\r\n      validate: validate$2,\r\n      params: params$2\r\n  };\n\n  var validate$3 = function (value, _a) {\r\n      var _b = (_a === void 0 ? {} : _a).locale, locale = _b === void 0 ? '' : _b;\r\n      if (Array.isArray(value)) {\r\n          return value.every(function (val) { return validate$3(val, { locale: locale }); });\r\n      }\r\n      // Match at least one locale.\r\n      if (!locale) {\r\n          return Object.keys(alphaSpaces).some(function (loc) { return alphaSpaces[loc].test(value); });\r\n      }\r\n      return (alphaSpaces[locale] || alphaSpaces.en).test(value);\r\n  };\r\n  var params$3 = [\r\n      {\r\n          name: 'locale'\r\n      }\r\n  ];\r\n  var alpha_spaces = {\r\n      validate: validate$3,\r\n      params: params$3\r\n  };\n\n  var validate$4 = function (value, _a) {\r\n      var _b = _a === void 0 ? {} : _a, min = _b.min, max = _b.max;\r\n      if (Array.isArray(value)) {\r\n          return value.every(function (val) { return !!validate$4(val, { min: min, max: max }); });\r\n      }\r\n      return Number(min) <= value && Number(max) >= value;\r\n  };\r\n  var params$4 = [\r\n      {\r\n          name: 'min'\r\n      },\r\n      {\r\n          name: 'max'\r\n      }\r\n  ];\r\n  var between = {\r\n      validate: validate$4,\r\n      params: params$4\r\n  };\n\n  var validate$5 = function (value, _a) {\r\n      var target = _a.target;\r\n      return String(value) === String(target);\r\n  };\r\n  var params$5 = [\r\n      {\r\n          name: 'target',\r\n          isTarget: true\r\n      }\r\n  ];\r\n  var confirmed = {\r\n      validate: validate$5,\r\n      params: params$5\r\n  };\n\n  var validate$6 = function (value, _a) {\r\n      var length = _a.length;\r\n      if (Array.isArray(value)) {\r\n          return value.every(function (val) { return validate$6(val, { length: length }); });\r\n      }\r\n      var strVal = String(value);\r\n      return /^[0-9]*$/.test(strVal) && strVal.length === length;\r\n  };\r\n  var params$6 = [\r\n      {\r\n          name: 'length',\r\n          cast: function (value) {\r\n              return Number(value);\r\n          }\r\n      }\r\n  ];\r\n  var digits = {\r\n      validate: validate$6,\r\n      params: params$6\r\n  };\n\n  var validateImage = function (file, width, height) {\r\n      var URL = window.URL || window.webkitURL;\r\n      return new Promise(function (resolve) {\r\n          var image = new Image();\r\n          image.onerror = function () { return resolve(false); };\r\n          image.onload = function () { return resolve(image.width === width && image.height === height); };\r\n          image.src = URL.createObjectURL(file);\r\n      });\r\n  };\r\n  var validate$7 = function (files, _a) {\r\n      var width = _a.width, height = _a.height;\r\n      var list = [];\r\n      files = Array.isArray(files) ? files : [files];\r\n      for (var i = 0; i < files.length; i++) {\r\n          // if file is not an image, reject.\r\n          if (!/\\.(jpg|svg|jpeg|png|bmp|gif)$/i.test(files[i].name)) {\r\n              return Promise.resolve(false);\r\n          }\r\n          list.push(files[i]);\r\n      }\r\n      return Promise.all(list.map(function (file) { return validateImage(file, width, height); })).then(function (values) {\r\n          return values.every(function (v) { return v; });\r\n      });\r\n  };\r\n  var params$7 = [\r\n      {\r\n          name: 'width',\r\n          cast: function (value) {\r\n              return Number(value);\r\n          }\r\n      },\r\n      {\r\n          name: 'height',\r\n          cast: function (value) {\r\n              return Number(value);\r\n          }\r\n      }\r\n  ];\r\n  var dimensions = {\r\n      validate: validate$7,\r\n      params: params$7\r\n  };\n\n  var validate$8 = function (value, _a) {\r\n      var multiple = (_a === void 0 ? {} : _a).multiple;\r\n      // eslint-disable-next-line\r\n      var re = /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\r\n      if (multiple && !Array.isArray(value)) {\r\n          value = String(value)\r\n              .split(',')\r\n              .map(function (emailStr) { return emailStr.trim(); });\r\n      }\r\n      if (Array.isArray(value)) {\r\n          return value.every(function (val) { return re.test(String(val)); });\r\n      }\r\n      return re.test(String(value));\r\n  };\r\n  var params$8 = [\r\n      {\r\n          name: 'multiple',\r\n          default: false\r\n      }\r\n  ];\r\n  var email = {\r\n      validate: validate$8,\r\n      params: params$8\r\n  };\n\n  var isNaN$1 = function (value) {\r\n      // NaN is the one value that does not equal itself.\r\n      // eslint-disable-next-line\r\n      return value !== value;\r\n  };\r\n  /**\r\n   * Checks if the values are either null or undefined.\r\n   */\r\n  var isNullOrUndefined = function (value) {\r\n      return value === null || value === undefined;\r\n  };\r\n  /**\r\n   * Creates the default flags object.\r\n   */\r\n  var createFlags = function () { return ({\r\n      untouched: true,\r\n      touched: false,\r\n      dirty: false,\r\n      pristine: true,\r\n      valid: false,\r\n      invalid: false,\r\n      validated: false,\r\n      pending: false,\r\n      required: false,\r\n      changed: false\r\n  }); };\r\n  /**\r\n   * Checks if the value is an object.\r\n   */\r\n  var isObject = function (obj) {\r\n      return obj !== null && obj && typeof obj === 'object' && !Array.isArray(obj);\r\n  };\r\n  function identity(x) {\r\n      return x;\r\n  }\r\n  /**\r\n   * Shallow object comparison.\r\n   */\r\n  var isEqual = function (lhs, rhs) {\r\n      if (lhs instanceof RegExp && rhs instanceof RegExp) {\r\n          return isEqual(lhs.source, rhs.source) && isEqual(lhs.flags, rhs.flags);\r\n      }\r\n      if (Array.isArray(lhs) && Array.isArray(rhs)) {\r\n          if (lhs.length !== rhs.length)\r\n              return false;\r\n          for (var i = 0; i < lhs.length; i++) {\r\n              if (!isEqual(lhs[i], rhs[i])) {\r\n                  return false;\r\n              }\r\n          }\r\n          return true;\r\n      }\r\n      // if both are objects, compare each key recursively.\r\n      if (isObject(lhs) && isObject(rhs)) {\r\n          return (Object.keys(lhs).every(function (key) {\r\n              return isEqual(lhs[key], rhs[key]);\r\n          }) &&\r\n              Object.keys(rhs).every(function (key) {\r\n                  return isEqual(lhs[key], rhs[key]);\r\n              }));\r\n      }\r\n      if (isNaN$1(lhs) && isNaN$1(rhs)) {\r\n          return true;\r\n      }\r\n      return lhs === rhs;\r\n  };\r\n  var includes = function (collection, item) {\r\n      return collection.indexOf(item) !== -1;\r\n  };\r\n  /**\r\n   * Parses a rule string expression.\r\n   */\r\n  var parseRule = function (rule) {\r\n      var params = [];\r\n      var name = rule.split(':')[0];\r\n      if (includes(rule, ':')) {\r\n          params = rule\r\n              .split(':')\r\n              .slice(1)\r\n              .join(':')\r\n              .split(',');\r\n      }\r\n      return { name: name, params: params };\r\n  };\r\n  /**\r\n   * Debounces a function.\r\n   */\r\n  var debounce = function (fn, wait, token) {\r\n      if (wait === void 0) { wait = 0; }\r\n      if (token === void 0) { token = { cancelled: false }; }\r\n      if (wait === 0) {\r\n          return fn;\r\n      }\r\n      var timeout;\r\n      return function () {\r\n          var args = [];\r\n          for (var _i = 0; _i < arguments.length; _i++) {\r\n              args[_i] = arguments[_i];\r\n          }\r\n          var later = function () {\r\n              timeout = undefined;\r\n              // check if the fn call was cancelled.\r\n              if (!token.cancelled)\r\n                  fn.apply(void 0, args);\r\n          };\r\n          // because we might want to use Node.js setTimout for SSR.\r\n          clearTimeout(timeout);\r\n          timeout = setTimeout(later, wait);\r\n      };\r\n  };\r\n  /**\r\n   * Emits a warning to the console.\r\n   */\r\n  var warn = function (message) {\r\n      console.warn(\"[vee-validate] \" + message);\r\n  };\r\n  /**\r\n   * Normalizes the given rules expression.\r\n   */\r\n  var normalizeRules = function (rules) {\r\n      // if falsy value return an empty object.\r\n      var acc = {};\r\n      Object.defineProperty(acc, '_$$isNormalized', {\r\n          value: true,\r\n          writable: false,\r\n          enumerable: false,\r\n          configurable: false\r\n      });\r\n      if (!rules) {\r\n          return acc;\r\n      }\r\n      // Object is already normalized, skip.\r\n      if (isObject(rules) && rules._$$isNormalized) {\r\n          return rules;\r\n      }\r\n      if (isObject(rules)) {\r\n          return Object.keys(rules).reduce(function (prev, curr) {\r\n              var params = [];\r\n              if (rules[curr] === true) {\r\n                  params = [];\r\n              }\r\n              else if (Array.isArray(rules[curr])) {\r\n                  params = rules[curr];\r\n              }\r\n              else if (isObject(rules[curr])) {\r\n                  params = rules[curr];\r\n              }\r\n              else {\r\n                  params = [rules[curr]];\r\n              }\r\n              if (rules[curr] !== false) {\r\n                  prev[curr] = params;\r\n              }\r\n              return prev;\r\n          }, acc);\r\n      }\r\n      /* istanbul ignore if */\r\n      if (typeof rules !== 'string') {\r\n          warn('rules must be either a string or an object.');\r\n          return acc;\r\n      }\r\n      return rules.split('|').reduce(function (prev, rule) {\r\n          var parsedRule = parseRule(rule);\r\n          prev[parsedRule.name] = parsedRule.params;\r\n          return prev;\r\n      }, acc);\r\n  };\r\n  /**\r\n   * Checks if a function is callable.\r\n   */\r\n  var isCallable = function (func) { return typeof func === 'function'; };\r\n  function computeClassObj(names, flags) {\r\n      var acc = {};\r\n      var keys = Object.keys(flags);\r\n      var length = keys.length;\r\n      var _loop_1 = function (i) {\r\n          var flag = keys[i];\r\n          var className = (names && names[flag]) || flag;\r\n          var value = flags[flag];\r\n          if (isNullOrUndefined(value)) {\r\n              return \"continue\";\r\n          }\r\n          if ((flag === 'valid' || flag === 'invalid') && !flags.validated) {\r\n              return \"continue\";\r\n          }\r\n          if (typeof className === 'string') {\r\n              acc[className] = value;\r\n          }\r\n          else if (Array.isArray(className)) {\r\n              className.forEach(function (cls) {\r\n                  acc[cls] = value;\r\n              });\r\n          }\r\n      };\r\n      for (var i = 0; i < length; i++) {\r\n          _loop_1(i);\r\n      }\r\n      return acc;\r\n  }\r\n  /* istanbul ignore next */\r\n  function _copyArray(arrayLike) {\r\n      var array = [];\r\n      var length = arrayLike.length;\r\n      for (var i = 0; i < length; i++) {\r\n          array.push(arrayLike[i]);\r\n      }\r\n      return array;\r\n  }\r\n  /**\r\n   * Converts an array-like object to array, provides a simple polyfill for Array.from\r\n   */\r\n  function toArray(arrayLike) {\r\n      if (isCallable(Array.from)) {\r\n          return Array.from(arrayLike);\r\n      }\r\n      /* istanbul ignore next */\r\n      return _copyArray(arrayLike);\r\n  }\r\n  function findIndex(arrayLike, predicate) {\r\n      var array = Array.isArray(arrayLike) ? arrayLike : toArray(arrayLike);\r\n      if (isCallable(array.findIndex)) {\r\n          return array.findIndex(predicate);\r\n      }\r\n      /* istanbul ignore next */\r\n      for (var i = 0; i < array.length; i++) {\r\n          if (predicate(array[i], i)) {\r\n              return i;\r\n          }\r\n      }\r\n      /* istanbul ignore next */\r\n      return -1;\r\n  }\r\n  /**\r\n   * finds the first element that satisfies the predicate callback, polyfills array.find\r\n   */\r\n  function find(arrayLike, predicate) {\r\n      var array = Array.isArray(arrayLike) ? arrayLike : toArray(arrayLike);\r\n      var idx = findIndex(array, predicate);\r\n      return idx === -1 ? undefined : array[idx];\r\n  }\r\n  function merge(target, source) {\r\n      Object.keys(source).forEach(function (key) {\r\n          if (isObject(source[key])) {\r\n              if (!target[key]) {\r\n                  target[key] = {};\r\n              }\r\n              merge(target[key], source[key]);\r\n              return;\r\n          }\r\n          target[key] = source[key];\r\n      });\r\n      return target;\r\n  }\r\n  function values(obj) {\r\n      if (isCallable(Object.values)) {\r\n          return Object.values(obj);\r\n      }\r\n      // fallback to keys()\r\n      /* istanbul ignore next */\r\n      return Object.keys(obj).map(function (k) { return obj[k]; });\r\n  }\r\n  var isEmptyArray = function (arr) {\r\n      return Array.isArray(arr) && arr.length === 0;\r\n  };\r\n  var interpolate = function (template, values) {\r\n      return template.replace(/\\{([^}]+)\\}/g, function (_, p) {\r\n          return p in values ? values[p] : \"{\" + p + \"}\";\r\n      });\r\n  };\r\n  // Checks if a given value is not an empty string or null or undefined.\r\n  var isSpecified = function (val) {\r\n      if (val === '') {\r\n          return false;\r\n      }\r\n      return !isNullOrUndefined(val);\r\n  };\n\n  var validate$9 = function (value, options) {\r\n      if (Array.isArray(value)) {\r\n          return value.every(function (val) { return validate$9(val, options); });\r\n      }\r\n      return toArray(options).some(function (item) {\r\n          // eslint-disable-next-line\r\n          return item == value;\r\n      });\r\n  };\r\n  var oneOf = {\r\n      validate: validate$9\r\n  };\n\n  var validate$a = function (value, args) {\r\n      return !validate$9(value, args);\r\n  };\r\n  var excluded = {\r\n      validate: validate$a\r\n  };\n\n  var validate$b = function (files, extensions) {\r\n      var regex = new RegExp(\".(\" + extensions.join('|') + \")$\", 'i');\r\n      if (Array.isArray(files)) {\r\n          return files.every(function (file) { return regex.test(file.name); });\r\n      }\r\n      return regex.test(files.name);\r\n  };\r\n  var ext = {\r\n      validate: validate$b\r\n  };\n\n  var validate$c = function (files) {\r\n      var regex = /\\.(jpg|svg|jpeg|png|bmp|gif)$/i;\r\n      if (Array.isArray(files)) {\r\n          return files.every(function (file) { return regex.test(file.name); });\r\n      }\r\n      return regex.test(files.name);\r\n  };\r\n  var image = {\r\n      validate: validate$c\r\n  };\n\n  var validate$d = function (value) {\r\n      if (Array.isArray(value)) {\r\n          return value.every(function (val) { return /^-?[0-9]+$/.test(String(val)); });\r\n      }\r\n      return /^-?[0-9]+$/.test(String(value));\r\n  };\r\n  var integer = {\r\n      validate: validate$d\r\n  };\n\n  var validate$e = function (value, _a) {\r\n      var other = _a.other;\r\n      return value === other;\r\n  };\r\n  var params$9 = [\r\n      {\r\n          name: 'other'\r\n      }\r\n  ];\r\n  var is = {\r\n      validate: validate$e,\r\n      params: params$9\r\n  };\n\n  var validate$f = function (value, _a) {\r\n      var other = _a.other;\r\n      return value !== other;\r\n  };\r\n  var params$a = [\r\n      {\r\n          name: 'other'\r\n      }\r\n  ];\r\n  var is_not = {\r\n      validate: validate$f,\r\n      params: params$a\r\n  };\n\n  var validate$g = function (value, _a) {\r\n      var length = _a.length;\r\n      if (isNullOrUndefined(value)) {\r\n          return false;\r\n      }\r\n      if (typeof value === 'number') {\r\n          value = String(value);\r\n      }\r\n      if (!value.length) {\r\n          value = toArray(value);\r\n      }\r\n      return value.length === length;\r\n  };\r\n  var params$b = [\r\n      {\r\n          name: 'length',\r\n          cast: function (value) { return Number(value); }\r\n      }\r\n  ];\r\n  var length = {\r\n      validate: validate$g,\r\n      params: params$b\r\n  };\n\n  var validate$h = function (value, _a) {\r\n      var length = _a.length;\r\n      if (isNullOrUndefined(value)) {\r\n          return length >= 0;\r\n      }\r\n      if (Array.isArray(value)) {\r\n          return value.every(function (val) { return validate$h(val, { length: length }); });\r\n      }\r\n      return String(value).length <= length;\r\n  };\r\n  var params$c = [\r\n      {\r\n          name: 'length',\r\n          cast: function (value) {\r\n              return Number(value);\r\n          }\r\n      }\r\n  ];\r\n  var max = {\r\n      validate: validate$h,\r\n      params: params$c\r\n  };\n\n  var validate$i = function (value, _a) {\r\n      var max = _a.max;\r\n      if (isNullOrUndefined(value) || value === '') {\r\n          return false;\r\n      }\r\n      if (Array.isArray(value)) {\r\n          return value.length > 0 && value.every(function (val) { return validate$i(val, { max: max }); });\r\n      }\r\n      return Number(value) <= max;\r\n  };\r\n  var params$d = [\r\n      {\r\n          name: 'max',\r\n          cast: function (value) {\r\n              return Number(value);\r\n          }\r\n      }\r\n  ];\r\n  var max_value = {\r\n      validate: validate$i,\r\n      params: params$d\r\n  };\n\n  var validate$j = function (files, mimes) {\r\n      var regex = new RegExp(mimes.join('|').replace('*', '.+') + \"$\", 'i');\r\n      if (Array.isArray(files)) {\r\n          return files.every(function (file) { return regex.test(file.type); });\r\n      }\r\n      return regex.test(files.type);\r\n  };\r\n  var mimes = {\r\n      validate: validate$j\r\n  };\n\n  var validate$k = function (value, _a) {\r\n      var length = _a.length;\r\n      if (isNullOrUndefined(value)) {\r\n          return false;\r\n      }\r\n      if (Array.isArray(value)) {\r\n          return value.every(function (val) { return validate$k(val, { length: length }); });\r\n      }\r\n      return String(value).length >= length;\r\n  };\r\n  var params$e = [\r\n      {\r\n          name: 'length',\r\n          cast: function (value) {\r\n              return Number(value);\r\n          }\r\n      }\r\n  ];\r\n  var min = {\r\n      validate: validate$k,\r\n      params: params$e\r\n  };\n\n  var validate$l = function (value, _a) {\r\n      var min = _a.min;\r\n      if (isNullOrUndefined(value) || value === '') {\r\n          return false;\r\n      }\r\n      if (Array.isArray(value)) {\r\n          return value.length > 0 && value.every(function (val) { return validate$l(val, { min: min }); });\r\n      }\r\n      return Number(value) >= min;\r\n  };\r\n  var params$f = [\r\n      {\r\n          name: 'min',\r\n          cast: function (value) {\r\n              return Number(value);\r\n          }\r\n      }\r\n  ];\r\n  var min_value = {\r\n      validate: validate$l,\r\n      params: params$f\r\n  };\n\n  var ar = /^[٠١٢٣٤٥٦٧٨٩]+$/;\r\n  var en$1 = /^[0-9]+$/;\r\n  var validate$m = function (value) {\r\n      var testValue = function (val) {\r\n          var strValue = String(val);\r\n          return en$1.test(strValue) || ar.test(strValue);\r\n      };\r\n      if (Array.isArray(value)) {\r\n          return value.every(testValue);\r\n      }\r\n      return testValue(value);\r\n  };\r\n  var numeric = {\r\n      validate: validate$m\r\n  };\n\n  var validate$n = function (value, _a) {\r\n      var regex = _a.regex;\r\n      if (Array.isArray(value)) {\r\n          return value.every(function (val) { return validate$n(val, { regex: regex }); });\r\n      }\r\n      return regex.test(String(value));\r\n  };\r\n  var params$g = [\r\n      {\r\n          name: 'regex',\r\n          cast: function (value) {\r\n              if (typeof value === 'string') {\r\n                  return new RegExp(value);\r\n              }\r\n              return value;\r\n          }\r\n      }\r\n  ];\r\n  var regex = {\r\n      validate: validate$n,\r\n      params: params$g\r\n  };\n\n  var validate$o = function (value, _a) {\r\n      var allowFalse = (_a === void 0 ? { allowFalse: true } : _a).allowFalse;\r\n      var result = {\r\n          valid: false,\r\n          required: true\r\n      };\r\n      if (isNullOrUndefined(value) || isEmptyArray(value)) {\r\n          return result;\r\n      }\r\n      // incase a field considers `false` as an empty value like checkboxes.\r\n      if (value === false && !allowFalse) {\r\n          return result;\r\n      }\r\n      result.valid = !!String(value).trim().length;\r\n      return result;\r\n  };\r\n  var computesRequired = true;\r\n  var params$h = [\r\n      {\r\n          name: 'allowFalse',\r\n          default: true\r\n      }\r\n  ];\r\n  var required = {\r\n      validate: validate$o,\r\n      params: params$h,\r\n      computesRequired: computesRequired\r\n  };\n\n  var testEmpty = function (value) {\r\n      return isEmptyArray(value) || includes([false, null, undefined], value) || !String(value).trim().length;\r\n  };\r\n  var validate$p = function (value, _a) {\r\n      var target = _a.target, values = _a.values;\r\n      var required;\r\n      if (values && values.length) {\r\n          // eslint-ignore-next-line\r\n          required = values.some(function (val) { return val == String(target).trim(); });\r\n      }\r\n      else {\r\n          required = !testEmpty(target);\r\n      }\r\n      if (!required) {\r\n          return {\r\n              valid: true,\r\n              required: required\r\n          };\r\n      }\r\n      return {\r\n          valid: !testEmpty(value),\r\n          required: required\r\n      };\r\n  };\r\n  var params$i = [\r\n      {\r\n          name: 'target',\r\n          isTarget: true\r\n      },\r\n      {\r\n          name: 'values'\r\n      }\r\n  ];\r\n  var computesRequired$1 = true;\r\n  var required_if = {\r\n      validate: validate$p,\r\n      params: params$i,\r\n      computesRequired: computesRequired$1\r\n  };\n\n  var validate$q = function (files, _a) {\r\n      var size = _a.size;\r\n      if (isNaN(size)) {\r\n          return false;\r\n      }\r\n      var nSize = size * 1024;\r\n      if (!Array.isArray(files)) {\r\n          return files.size <= nSize;\r\n      }\r\n      for (var i = 0; i < files.length; i++) {\r\n          if (files[i].size > nSize) {\r\n              return false;\r\n          }\r\n      }\r\n      return true;\r\n  };\r\n  var params$j = [\r\n      {\r\n          name: 'size',\r\n          cast: function (value) {\r\n              return Number(value);\r\n          }\r\n      }\r\n  ];\r\n  var size = {\r\n      validate: validate$q,\r\n      params: params$j\r\n  };\n\n\n\n  var Rules = /*#__PURE__*/Object.freeze({\n    alpha_dash: alpha_dash,\n    alpha_num: alpha_num,\n    alpha_spaces: alpha_spaces,\n    alpha: alpha$1,\n    between: between,\n    confirmed: confirmed,\n    digits: digits,\n    dimensions: dimensions,\n    email: email,\n    ext: ext,\n    image: image,\n    oneOf: oneOf,\n    integer: integer,\n    length: length,\n    is_not: is_not,\n    is: is,\n    max: max,\n    max_value: max_value,\n    mimes: mimes,\n    min: min,\n    min_value: min_value,\n    excluded: excluded,\n    numeric: numeric,\n    regex: regex,\n    required: required,\n    required_if: required_if,\n    size: size\n  });\n\n  /*! *****************************************************************************\r\n  Copyright (c) Microsoft Corporation. All rights reserved.\r\n  Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n  this file except in compliance with the License. You may obtain a copy of the\r\n  License at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n  MERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\n  See the Apache Version 2.0 License for specific language governing permissions\r\n  and limitations under the License.\r\n  ***************************************************************************** */\r\n\r\n  var __assign = function() {\r\n      __assign = Object.assign || function __assign(t) {\r\n          for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n              s = arguments[i];\r\n              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n          }\r\n          return t;\r\n      };\r\n      return __assign.apply(this, arguments);\r\n  };\r\n\r\n  function __awaiter(thisArg, _arguments, P, generator) {\r\n      return new (P || (P = Promise))(function (resolve, reject) {\r\n          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n          function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n          function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n          step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n      });\r\n  }\r\n\r\n  function __generator(thisArg, body) {\r\n      var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n      return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n      function verb(n) { return function (v) { return step([n, v]); }; }\r\n      function step(op) {\r\n          if (f) throw new TypeError(\"Generator is already executing.\");\r\n          while (_) try {\r\n              if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n              if (y = 0, t) op = [op[0] & 2, t.value];\r\n              switch (op[0]) {\r\n                  case 0: case 1: t = op; break;\r\n                  case 4: _.label++; return { value: op[1], done: false };\r\n                  case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                  case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                  default:\r\n                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                      if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                      if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                      if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                      if (t[2]) _.ops.pop();\r\n                      _.trys.pop(); continue;\r\n              }\r\n              op = body.call(thisArg, _);\r\n          } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n          if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n      }\r\n  }\r\n\r\n  function __spreadArrays() {\r\n      for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n      for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n              r[k] = a[j];\r\n      return r;\r\n  }\n\n  var RULES = {};\r\n  function normalizeSchema(schema) {\r\n      if (schema.params && schema.params.length) {\r\n          schema.params = schema.params.map(function (param) {\r\n              if (typeof param === 'string') {\r\n                  return { name: param };\r\n              }\r\n              return param;\r\n          });\r\n      }\r\n      return schema;\r\n  }\r\n  var RuleContainer = /** @class */ (function () {\r\n      function RuleContainer() {\r\n      }\r\n      RuleContainer.extend = function (name, schema) {\r\n          // if rule already exists, overwrite it.\r\n          var rule = normalizeSchema(schema);\r\n          if (RULES[name]) {\r\n              RULES[name] = merge(RULES[name], schema);\r\n              return;\r\n          }\r\n          RULES[name] = __assign({ lazy: false, computesRequired: false }, rule);\r\n      };\r\n      RuleContainer.iterate = function (fn) {\r\n          var keys = Object.keys(RULES);\r\n          var length = keys.length;\r\n          for (var i = 0; i < length; i++) {\r\n              fn(keys[i], RULES[keys[i]]);\r\n          }\r\n      };\r\n      RuleContainer.isLazy = function (name) {\r\n          return !!(RULES[name] && RULES[name].lazy);\r\n      };\r\n      RuleContainer.isRequireRule = function (name) {\r\n          return !!(RULES[name] && RULES[name].computesRequired);\r\n      };\r\n      RuleContainer.isTargetRule = function (name) {\r\n          var definition = RuleContainer.getRuleDefinition(name);\r\n          if (!definition || !definition.params) {\r\n              return false;\r\n          }\r\n          return definition.params.some(function (param) { return !!param.isTarget; });\r\n      };\r\n      RuleContainer.getTargetParamNames = function (rule, params) {\r\n          var definition = RuleContainer.getRuleDefinition(rule);\r\n          if (Array.isArray(params)) {\r\n              return params.filter(function (_, idx) {\r\n                  return definition.params && find(definition.params, function (p, i) { return !!p.isTarget && i === idx; });\r\n              });\r\n          }\r\n          return Object.keys(params)\r\n              .filter(function (key) {\r\n              return definition.params && find(definition.params, function (p) { return !!p.isTarget && p.name === key; });\r\n          })\r\n              .map(function (key) { return params[key]; });\r\n      };\r\n      RuleContainer.getRuleDefinition = function (ruleName) {\r\n          return RULES[ruleName];\r\n      };\r\n      return RuleContainer;\r\n  }());\r\n  /**\r\n   * Adds a custom validator to the list of validation rules.\r\n   */\r\n  function extend(name, schema) {\r\n      // makes sure new rules are properly formatted.\r\n      guardExtend(name, schema);\r\n      // Full schema object.\r\n      if (typeof schema === 'object') {\r\n          RuleContainer.extend(name, schema);\r\n          return;\r\n      }\r\n      RuleContainer.extend(name, {\r\n          validate: schema\r\n      });\r\n  }\r\n  /**\r\n   * Guards from extension violations.\r\n   */\r\n  function guardExtend(name, validator) {\r\n      if (isCallable(validator)) {\r\n          return;\r\n      }\r\n      if (isCallable(validator.validate)) {\r\n          return;\r\n      }\r\n      if (RuleContainer.getRuleDefinition(name)) {\r\n          return;\r\n      }\r\n      throw new Error(\"Extension Error: The validator '\" + name + \"' must be a function or have a 'validate' method.\");\r\n  }\n\n  var DEFAULT_CONFIG = {\r\n      defaultMessage: \"{_field_} is not valid.\",\r\n      skipOptional: true,\r\n      classes: {\r\n          touched: 'touched',\r\n          untouched: 'untouched',\r\n          valid: 'valid',\r\n          invalid: 'invalid',\r\n          pristine: 'pristine',\r\n          dirty: 'dirty' // control has been interacted with\r\n      },\r\n      bails: true,\r\n      mode: 'aggressive',\r\n      useConstraintAttrs: true\r\n  };\r\n  var currentConfig = __assign({}, DEFAULT_CONFIG);\r\n  var getConfig = function () { return currentConfig; };\r\n  var setConfig = function (newConf) {\r\n      currentConfig = __assign(__assign({}, currentConfig), newConf);\r\n  };\r\n  var configure = function (cfg) {\r\n      setConfig(cfg);\r\n  };\n\n  var Dictionary = /** @class */ (function () {\r\n      function Dictionary(locale, dictionary) {\r\n          this.container = {};\r\n          this.locale = locale;\r\n          this.merge(dictionary);\r\n      }\r\n      Dictionary.prototype.resolve = function (field, rule, values) {\r\n          return this.format(this.locale, field, rule, values);\r\n      };\r\n      Dictionary.prototype._hasLocale = function (locale) {\r\n          return !!this.container[locale];\r\n      };\r\n      Dictionary.prototype.format = function (locale, field, rule, values) {\r\n          var message;\r\n          // find if specific message for that field was specified.\r\n          var dict = this.container[locale] && this.container[locale].fields && this.container[locale].fields[field];\r\n          if (dict && dict[rule]) {\r\n              message = dict[rule];\r\n          }\r\n          if (!message && this._hasLocale(locale) && this._hasMessage(locale, rule)) {\r\n              message = this.container[locale].messages[rule];\r\n          }\r\n          if (!message) {\r\n              message = getConfig().defaultMessage;\r\n          }\r\n          if (this._hasName(locale, field)) {\r\n              field = this.getName(locale, field);\r\n          }\r\n          return isCallable(message) ? message(field, values) : interpolate(message, __assign(__assign({}, values), { _field_: field }));\r\n      };\r\n      Dictionary.prototype.merge = function (dictionary) {\r\n          merge(this.container, dictionary);\r\n      };\r\n      Dictionary.prototype.hasRule = function (name) {\r\n          var locale = this.container[this.locale];\r\n          if (!locale)\r\n              return false;\r\n          return !!(locale.messages && locale.messages[name]);\r\n      };\r\n      Dictionary.prototype.getName = function (locale, key) {\r\n          return this.container[locale].names[key];\r\n      };\r\n      Dictionary.prototype._hasMessage = function (locale, key) {\r\n          return !!(this._hasLocale(locale) && this.container[locale].messages && this.container[locale].messages[key]);\r\n      };\r\n      Dictionary.prototype._hasName = function (locale, key) {\r\n          return !!(this._hasLocale(locale) && this.container[locale].names && this.container[locale].names[key]);\r\n      };\r\n      return Dictionary;\r\n  }());\r\n  var DICTIONARY;\r\n  var INSTALLED = false;\r\n  function updateRules() {\r\n      if (INSTALLED) {\r\n          return;\r\n      }\r\n      RuleContainer.iterate(function (name, schema) {\r\n          var _a, _b;\r\n          if (schema.message && !DICTIONARY.hasRule(name)) {\r\n              DICTIONARY.merge((_a = {},\r\n                  _a[DICTIONARY.locale] = {\r\n                      messages: (_b = {},\r\n                          _b[name] = schema.message,\r\n                          _b)\r\n                  },\r\n                  _a));\r\n          }\r\n          extend(name, {\r\n              message: function (field, values) {\r\n                  return DICTIONARY.resolve(field, name, values || {});\r\n              }\r\n          });\r\n      });\r\n      INSTALLED = true;\r\n  }\r\n  function localize(locale, dictionary) {\r\n      var _a;\r\n      if (!DICTIONARY) {\r\n          DICTIONARY = new Dictionary('en', {});\r\n      }\r\n      if (typeof locale === 'string') {\r\n          DICTIONARY.locale = locale;\r\n          if (dictionary) {\r\n              DICTIONARY.merge((_a = {}, _a[locale] = dictionary, _a));\r\n          }\r\n          updateRules();\r\n          return;\r\n      }\r\n      DICTIONARY.merge(locale);\r\n      updateRules();\r\n  }\n\n  var aggressive = function () { return ({\r\n      on: ['input', 'blur']\r\n  }); };\r\n  var lazy = function () { return ({\r\n      on: ['change']\r\n  }); };\r\n  var eager = function (_a) {\r\n      var errors = _a.errors;\r\n      if (errors.length) {\r\n          return {\r\n              on: ['input', 'change']\r\n          };\r\n      }\r\n      return {\r\n          on: ['change', 'blur']\r\n      };\r\n  };\r\n  var passive = function () { return ({\r\n      on: []\r\n  }); };\r\n  var modes = {\r\n      aggressive: aggressive,\r\n      eager: eager,\r\n      passive: passive,\r\n      lazy: lazy\r\n  };\r\n  var setInteractionMode = function (mode, implementation) {\r\n      setConfig({ mode: mode });\r\n      if (!implementation) {\r\n          return;\r\n      }\r\n      if (!isCallable(implementation)) {\r\n          throw new Error('A mode implementation must be a function');\r\n      }\r\n      modes[mode] = implementation;\r\n  };\n\n  /**\r\n   * Validates a value against the rules.\r\n   */\r\n  function validate$r(value, rules, options) {\r\n      if (options === void 0) { options = {}; }\r\n      return __awaiter(this, void 0, void 0, function () {\r\n          var shouldBail, skipIfEmpty, field, result, errors, ruleMap;\r\n          return __generator(this, function (_a) {\r\n              switch (_a.label) {\r\n                  case 0:\r\n                      shouldBail = options && options.bails;\r\n                      skipIfEmpty = options && options.skipIfEmpty;\r\n                      field = {\r\n                          name: (options && options.name) || '{field}',\r\n                          rules: normalizeRules(rules),\r\n                          bails: isNullOrUndefined(shouldBail) ? true : shouldBail,\r\n                          skipIfEmpty: isNullOrUndefined(skipIfEmpty) ? true : skipIfEmpty,\r\n                          forceRequired: false,\r\n                          crossTable: (options && options.values) || {},\r\n                          names: (options && options.names) || {},\r\n                          customMessages: (options && options.customMessages) || {}\r\n                      };\r\n                      return [4 /*yield*/, _validate(field, value, options)];\r\n                  case 1:\r\n                      result = _a.sent();\r\n                      errors = [];\r\n                      ruleMap = {};\r\n                      result.errors.forEach(function (e) {\r\n                          errors.push(e.msg);\r\n                          ruleMap[e.rule] = e.msg;\r\n                      });\r\n                      return [2 /*return*/, {\r\n                              valid: result.valid,\r\n                              errors: errors,\r\n                              failedRules: ruleMap\r\n                          }];\r\n              }\r\n          });\r\n      });\r\n  }\r\n  /**\r\n   * Starts the validation process.\r\n   */\r\n  function _validate(field, value, _a) {\r\n      var _b = (_a === void 0 ? {} : _a).isInitial, isInitial = _b === void 0 ? false : _b;\r\n      return __awaiter(this, void 0, void 0, function () {\r\n          var _c, shouldSkip, errors, rules, length, i, rule, result;\r\n          return __generator(this, function (_d) {\r\n              switch (_d.label) {\r\n                  case 0: return [4 /*yield*/, _shouldSkip(field, value)];\r\n                  case 1:\r\n                      _c = _d.sent(), shouldSkip = _c.shouldSkip, errors = _c.errors;\r\n                      if (shouldSkip) {\r\n                          return [2 /*return*/, {\r\n                                  valid: !errors.length,\r\n                                  errors: errors\r\n                              }];\r\n                      }\r\n                      rules = Object.keys(field.rules).filter(function (rule) { return !RuleContainer.isRequireRule(rule); });\r\n                      length = rules.length;\r\n                      i = 0;\r\n                      _d.label = 2;\r\n                  case 2:\r\n                      if (!(i < length)) return [3 /*break*/, 5];\r\n                      if (isInitial && RuleContainer.isLazy(rules[i])) {\r\n                          return [3 /*break*/, 4];\r\n                      }\r\n                      rule = rules[i];\r\n                      return [4 /*yield*/, _test(field, value, {\r\n                              name: rule,\r\n                              params: field.rules[rule]\r\n                          })];\r\n                  case 3:\r\n                      result = _d.sent();\r\n                      if (!result.valid && result.error) {\r\n                          errors.push(result.error);\r\n                          if (field.bails) {\r\n                              return [2 /*return*/, {\r\n                                      valid: false,\r\n                                      errors: errors\r\n                                  }];\r\n                          }\r\n                      }\r\n                      _d.label = 4;\r\n                  case 4:\r\n                      i++;\r\n                      return [3 /*break*/, 2];\r\n                  case 5: return [2 /*return*/, {\r\n                          valid: !errors.length,\r\n                          errors: errors\r\n                      }];\r\n              }\r\n          });\r\n      });\r\n  }\r\n  function _shouldSkip(field, value) {\r\n      return __awaiter(this, void 0, void 0, function () {\r\n          var requireRules, length, errors, isEmpty, isEmptyAndOptional, isRequired, i, rule, result;\r\n          return __generator(this, function (_a) {\r\n              switch (_a.label) {\r\n                  case 0:\r\n                      requireRules = Object.keys(field.rules).filter(RuleContainer.isRequireRule);\r\n                      length = requireRules.length;\r\n                      errors = [];\r\n                      isEmpty = isNullOrUndefined(value) || value === '' || isEmptyArray(value);\r\n                      isEmptyAndOptional = isEmpty && field.skipIfEmpty;\r\n                      isRequired = false;\r\n                      i = 0;\r\n                      _a.label = 1;\r\n                  case 1:\r\n                      if (!(i < length)) return [3 /*break*/, 4];\r\n                      rule = requireRules[i];\r\n                      return [4 /*yield*/, _test(field, value, {\r\n                              name: rule,\r\n                              params: field.rules[rule]\r\n                          })];\r\n                  case 2:\r\n                      result = _a.sent();\r\n                      if (!isObject(result)) {\r\n                          throw new Error('Require rules has to return an object (see docs)');\r\n                      }\r\n                      if (result.required) {\r\n                          isRequired = true;\r\n                      }\r\n                      if (!result.valid && result.error) {\r\n                          errors.push(result.error);\r\n                          // Exit early as the field is required and failed validation.\r\n                          if (field.bails) {\r\n                              return [2 /*return*/, {\r\n                                      shouldSkip: true,\r\n                                      errors: errors\r\n                                  }];\r\n                          }\r\n                      }\r\n                      _a.label = 3;\r\n                  case 3:\r\n                      i++;\r\n                      return [3 /*break*/, 1];\r\n                  case 4:\r\n                      if (isEmpty && !isRequired && !field.skipIfEmpty) {\r\n                          return [2 /*return*/, {\r\n                                  shouldSkip: false,\r\n                                  errors: errors\r\n                              }];\r\n                      }\r\n                      // field is configured to run through the pipeline regardless\r\n                      if (!field.bails && !isEmptyAndOptional) {\r\n                          return [2 /*return*/, {\r\n                                  shouldSkip: false,\r\n                                  errors: errors\r\n                              }];\r\n                      }\r\n                      // skip if the field is not required and has an empty value.\r\n                      return [2 /*return*/, {\r\n                              shouldSkip: !isRequired && isEmpty,\r\n                              errors: errors\r\n                          }];\r\n              }\r\n          });\r\n      });\r\n  }\r\n  /**\r\n   * Tests a single input value against a rule.\r\n   */\r\n  function _test(field, value, rule) {\r\n      return __awaiter(this, void 0, void 0, function () {\r\n          var ruleSchema, params, normalizedValue, result, values;\r\n          return __generator(this, function (_a) {\r\n              switch (_a.label) {\r\n                  case 0:\r\n                      ruleSchema = RuleContainer.getRuleDefinition(rule.name);\r\n                      if (!ruleSchema || !ruleSchema.validate) {\r\n                          throw new Error(\"No such validator '\" + rule.name + \"' exists.\");\r\n                      }\r\n                      params = _buildParams(rule.params, ruleSchema.params, field.crossTable);\r\n                      normalizedValue = ruleSchema.castValue ? ruleSchema.castValue(value) : value;\r\n                      return [4 /*yield*/, ruleSchema.validate(normalizedValue, params)];\r\n                  case 1:\r\n                      result = _a.sent();\r\n                      if (typeof result === 'string') {\r\n                          values = __assign(__assign({}, (params || {})), { _field_: field.name, _value_: value, _rule_: rule.name });\r\n                          return [2 /*return*/, {\r\n                                  valid: false,\r\n                                  error: { rule: rule.name, msg: interpolate(result, values) }\r\n                              }];\r\n                      }\r\n                      if (!isObject(result)) {\r\n                          result = { valid: result, data: {} };\r\n                      }\r\n                      return [2 /*return*/, {\r\n                              valid: result.valid,\r\n                              required: result.required,\r\n                              data: result.data || {},\r\n                              error: result.valid ? undefined : _generateFieldError(field, value, ruleSchema, rule.name, params, result.data)\r\n                          }];\r\n              }\r\n          });\r\n      });\r\n  }\r\n  /**\r\n   * Generates error messages.\r\n   */\r\n  function _generateFieldError(field, value, ruleSchema, ruleName, params, data) {\r\n      var values = __assign(__assign(__assign(__assign({}, (params || {})), (data || {})), { _field_: field.name, _value_: value, _rule_: ruleName }), _getTargetNames(field, ruleSchema, ruleName));\r\n      if (Object.prototype.hasOwnProperty.call(field.customMessages, ruleName) &&\r\n          typeof field.customMessages[ruleName] === 'string') {\r\n          return {\r\n              msg: _normalizeMessage(field.customMessages[ruleName], field.name, values),\r\n              rule: ruleName\r\n          };\r\n      }\r\n      if (ruleSchema.message) {\r\n          return {\r\n              msg: _normalizeMessage(ruleSchema.message, field.name, values),\r\n              rule: ruleName\r\n          };\r\n      }\r\n      return {\r\n          msg: _normalizeMessage(getConfig().defaultMessage, field.name, values),\r\n          rule: ruleName\r\n      };\r\n  }\r\n  function _getTargetNames(field, ruleSchema, ruleName) {\r\n      if (ruleSchema.params) {\r\n          var numTargets = ruleSchema.params.filter(function (param) { return param.isTarget; }).length;\r\n          if (numTargets > 0) {\r\n              var names = {};\r\n              for (var index = 0; index < ruleSchema.params.length; index++) {\r\n                  var param = ruleSchema.params[index];\r\n                  if (param.isTarget) {\r\n                      var key = field.rules[ruleName][index];\r\n                      var name_1 = field.names[key] || key;\r\n                      if (numTargets === 1) {\r\n                          names._target_ = name_1;\r\n                          break;\r\n                      }\r\n                      else {\r\n                          names[\"_\" + param.name + \"Target_\"] = name_1;\r\n                      }\r\n                  }\r\n              }\r\n              return names;\r\n          }\r\n      }\r\n      return {};\r\n  }\r\n  function _normalizeMessage(template, field, values) {\r\n      if (typeof template === 'function') {\r\n          return template(field, values);\r\n      }\r\n      return interpolate(template, __assign(__assign({}, values), { _field_: field }));\r\n  }\r\n  function _buildParams(provided, defined, crossTable) {\r\n      var params = {};\r\n      if (!defined && !Array.isArray(provided)) {\r\n          throw new Error('You provided an object params to a rule that has no defined schema.');\r\n      }\r\n      // Rule probably uses an array for their args, keep it as is.\r\n      if (Array.isArray(provided) && !defined) {\r\n          return provided;\r\n      }\r\n      var definedRules;\r\n      // collect the params schema.\r\n      if (!defined || defined.length < provided.length) {\r\n          var lastDefinedParam_1;\r\n          // collect any additional parameters in the last item.\r\n          definedRules = provided.map(function (_, idx) {\r\n              var param = defined && defined[idx];\r\n              lastDefinedParam_1 = param || lastDefinedParam_1;\r\n              if (!param) {\r\n                  param = lastDefinedParam_1;\r\n              }\r\n              return param;\r\n          });\r\n      }\r\n      else {\r\n          definedRules = defined;\r\n      }\r\n      // Match the provided array length with a temporary schema.\r\n      for (var i = 0; i < definedRules.length; i++) {\r\n          var options = definedRules[i];\r\n          var value = options.default;\r\n          // if the provided is an array, map element value.\r\n          if (Array.isArray(provided)) {\r\n              if (i in provided) {\r\n                  value = provided[i];\r\n              }\r\n          }\r\n          else {\r\n              // If the param exists in the provided object.\r\n              if (options.name in provided) {\r\n                  value = provided[options.name];\r\n                  // if the provided is the first param value.\r\n              }\r\n              else if (definedRules.length === 1) {\r\n                  value = provided;\r\n              }\r\n          }\r\n          // if the param is a target, resolve the target value.\r\n          if (options.isTarget) {\r\n              value = crossTable[value];\r\n          }\r\n          // If there is a transformer defined.\r\n          if (options.cast) {\r\n              value = options.cast(value);\r\n          }\r\n          // already been set, probably multiple values.\r\n          if (params[options.name]) {\r\n              params[options.name] = Array.isArray(params[options.name]) ? params[options.name] : [params[options.name]];\r\n              params[options.name].push(value);\r\n          }\r\n          else {\r\n              // set the value.\r\n              params[options.name] = value;\r\n          }\r\n      }\r\n      return params;\r\n  }\n\n  function install(_, config) {\r\n      setConfig(config);\r\n  }\n\n  var isEvent = function (evt) {\r\n      if (!evt) {\r\n          return false;\r\n      }\r\n      if (typeof Event !== 'undefined' && isCallable(Event) && evt instanceof Event) {\r\n          return true;\r\n      }\r\n      // this is for IE\r\n      /* istanbul ignore next */\r\n      if (evt && evt.srcElement) {\r\n          return true;\r\n      }\r\n      return false;\r\n  };\r\n  function normalizeEventValue(value) {\r\n      if (!isEvent(value)) {\r\n          return value;\r\n      }\r\n      var input = value.target;\r\n      if (input.type === 'file' && input.files) {\r\n          return toArray(input.files);\r\n      }\r\n      return input.value;\r\n  }\n\n  var isTextInput = function (vnode) {\r\n      var attrs = (vnode.data && vnode.data.attrs) || vnode.elm;\r\n      // it will fallback to being a text input per browsers spec.\r\n      if (vnode.tag === 'input' && (!attrs || !attrs.type)) {\r\n          return true;\r\n      }\r\n      if (vnode.tag === 'textarea') {\r\n          return true;\r\n      }\r\n      return includes(['text', 'password', 'search', 'email', 'tel', 'url', 'number'], attrs && attrs.type);\r\n  };\r\n  // export const isCheckboxOrRadioInput = (vnode: VNode): boolean => {\r\n  //   const attrs = (vnode.data && vnode.data.attrs) || vnode.elm;\r\n  //   return includes(['radio', 'checkbox'], attrs && attrs.type);\r\n  // };\r\n  // Gets the model object on the vnode.\r\n  function findModel(vnode) {\r\n      if (!vnode.data) {\r\n          return undefined;\r\n      }\r\n      // Component Model\r\n      // THIS IS NOT TYPED IN OFFICIAL VUE TYPINGS\r\n      // eslint-disable-next-line\r\n      var nonStandardVNodeData = vnode.data;\r\n      if ('model' in nonStandardVNodeData) {\r\n          return nonStandardVNodeData.model;\r\n      }\r\n      if (!vnode.data.directives) {\r\n          return undefined;\r\n      }\r\n      return find(vnode.data.directives, function (d) { return d.name === 'model'; });\r\n  }\r\n  function findValue(vnode) {\r\n      var model = findModel(vnode);\r\n      if (model) {\r\n          return { value: model.value };\r\n      }\r\n      var config = findModelConfig(vnode);\r\n      var prop = (config && config.prop) || 'value';\r\n      if (vnode.componentOptions && vnode.componentOptions.propsData && prop in vnode.componentOptions.propsData) {\r\n          var propsDataWithValue = vnode.componentOptions.propsData;\r\n          return { value: propsDataWithValue[prop] };\r\n      }\r\n      if (vnode.data && vnode.data.domProps && 'value' in vnode.data.domProps) {\r\n          return { value: vnode.data.domProps.value };\r\n      }\r\n      return undefined;\r\n  }\r\n  function extractChildren(vnode) {\r\n      if (Array.isArray(vnode)) {\r\n          return vnode;\r\n      }\r\n      if (Array.isArray(vnode.children)) {\r\n          return vnode.children;\r\n      }\r\n      /* istanbul ignore next */\r\n      if (vnode.componentOptions && Array.isArray(vnode.componentOptions.children)) {\r\n          return vnode.componentOptions.children;\r\n      }\r\n      return [];\r\n  }\r\n  function extractVNodes(vnode) {\r\n      if (!Array.isArray(vnode) && findValue(vnode) !== undefined) {\r\n          return [vnode];\r\n      }\r\n      var children = extractChildren(vnode);\r\n      return children.reduce(function (nodes, node) {\r\n          var candidates = extractVNodes(node);\r\n          if (candidates.length) {\r\n              nodes.push.apply(nodes, candidates);\r\n          }\r\n          return nodes;\r\n      }, []);\r\n  }\r\n  // Resolves v-model config if exists.\r\n  function findModelConfig(vnode) {\r\n      /* istanbul ignore next */\r\n      if (!vnode.componentOptions)\r\n          return null;\r\n      // This is also not typed in the standard Vue TS.\r\n      return vnode.componentOptions.Ctor.options.model;\r\n  }\r\n  // Adds a listener to vnode listener object.\r\n  function mergeVNodeListeners(obj, eventName, handler) {\r\n      // no listener at all.\r\n      if (isNullOrUndefined(obj[eventName])) {\r\n          obj[eventName] = [handler];\r\n          return;\r\n      }\r\n      // Is an invoker.\r\n      if (isCallable(obj[eventName]) && obj[eventName].fns) {\r\n          var invoker = obj[eventName];\r\n          invoker.fns = Array.isArray(invoker.fns) ? invoker.fns : [invoker.fns];\r\n          if (!includes(invoker.fns, handler)) {\r\n              invoker.fns.push(handler);\r\n          }\r\n          return;\r\n      }\r\n      if (isCallable(obj[eventName])) {\r\n          var prev = obj[eventName];\r\n          obj[eventName] = [prev];\r\n      }\r\n      if (Array.isArray(obj[eventName]) && !includes(obj[eventName], handler)) {\r\n          obj[eventName].push(handler);\r\n      }\r\n  }\r\n  // Adds a listener to a native HTML vnode.\r\n  function addNativeNodeListener(node, eventName, handler) {\r\n      /* istanbul ignore next */\r\n      if (!node.data) {\r\n          node.data = {};\r\n      }\r\n      if (isNullOrUndefined(node.data.on)) {\r\n          node.data.on = {};\r\n      }\r\n      mergeVNodeListeners(node.data.on, eventName, handler);\r\n  }\r\n  // Adds a listener to a Vue component vnode.\r\n  function addComponentNodeListener(node, eventName, handler) {\r\n      /* istanbul ignore next */\r\n      if (!node.componentOptions) {\r\n          return;\r\n      }\r\n      /* istanbul ignore next */\r\n      if (!node.componentOptions.listeners) {\r\n          node.componentOptions.listeners = {};\r\n      }\r\n      mergeVNodeListeners(node.componentOptions.listeners, eventName, handler);\r\n  }\r\n  function addVNodeListener(vnode, eventName, handler) {\r\n      if (vnode.componentOptions) {\r\n          addComponentNodeListener(vnode, eventName, handler);\r\n          return;\r\n      }\r\n      addNativeNodeListener(vnode, eventName, handler);\r\n  }\r\n  // Determines if `change` should be used over `input` for listeners.\r\n  function getInputEventName(vnode, model) {\r\n      // Is a component.\r\n      if (vnode.componentOptions) {\r\n          var event_1 = (findModelConfig(vnode) || { event: 'input' }).event;\r\n          return event_1;\r\n      }\r\n      // Lazy Models typically use change event\r\n      if (model && model.modifiers && model.modifiers.lazy) {\r\n          return 'change';\r\n      }\r\n      // is a textual-type input.\r\n      if (isTextInput(vnode)) {\r\n          return 'input';\r\n      }\r\n      return 'change';\r\n  }\r\n  // TODO: Type this one properly.\r\n  function normalizeSlots(slots, ctx) {\r\n      var acc = [];\r\n      return Object.keys(slots).reduce(function (arr, key) {\r\n          slots[key].forEach(function (vnode) {\r\n              if (!vnode.context) {\r\n                  slots[key].context = ctx;\r\n                  if (!vnode.data) {\r\n                      vnode.data = {};\r\n                  }\r\n                  vnode.data.slot = key;\r\n              }\r\n          });\r\n          return arr.concat(slots[key]);\r\n      }, acc);\r\n  }\r\n  function resolveTextualRules(vnode) {\r\n      var attrs = vnode.data && vnode.data.attrs;\r\n      var rules = {};\r\n      if (!attrs)\r\n          return rules;\r\n      if (attrs.type === 'email') {\r\n          rules.email = ['multiple' in attrs];\r\n      }\r\n      if (attrs.pattern) {\r\n          rules.regex = attrs.pattern;\r\n      }\r\n      if (attrs.maxlength >= 0) {\r\n          rules.max = attrs.maxlength;\r\n      }\r\n      if (attrs.minlength >= 0) {\r\n          rules.min = attrs.minlength;\r\n      }\r\n      if (attrs.type === 'number') {\r\n          if (isSpecified(attrs.min)) {\r\n              rules.min_value = Number(attrs.min);\r\n          }\r\n          if (isSpecified(attrs.max)) {\r\n              rules.max_value = Number(attrs.max);\r\n          }\r\n      }\r\n      return rules;\r\n  }\r\n  function resolveRules(vnode) {\r\n      var htmlTags = ['input', 'select'];\r\n      var attrs = vnode.data && vnode.data.attrs;\r\n      if (!includes(htmlTags, vnode.tag) || !attrs) {\r\n          return {};\r\n      }\r\n      var rules = {};\r\n      if ('required' in attrs && attrs.required !== false) {\r\n          rules.required = attrs.type === 'checkbox' ? [true] : true;\r\n      }\r\n      if (isTextInput(vnode)) {\r\n          return normalizeRules(__assign(__assign({}, rules), resolveTextualRules(vnode)));\r\n      }\r\n      return normalizeRules(rules);\r\n  }\r\n  function normalizeChildren(context, slotProps) {\r\n      if (context.$scopedSlots.default) {\r\n          return context.$scopedSlots.default(slotProps) || [];\r\n      }\r\n      return context.$slots.default || [];\r\n  }\n\n  /**\r\n   * Determines if a provider needs to run validation.\r\n   */\r\n  function shouldValidate(ctx, value) {\r\n      // when an immediate/initial validation is needed and wasn't done before.\r\n      if (!ctx._ignoreImmediate && ctx.immediate) {\r\n          return true;\r\n      }\r\n      // when the value changes for whatever reason.\r\n      if (ctx.value !== value && ctx.normalizedEvents.length) {\r\n          return true;\r\n      }\r\n      // when it needs validation due to props/cross-fields changes.\r\n      if (ctx._needsValidation) {\r\n          return true;\r\n      }\r\n      // when the initial value is undefined and the field wasn't rendered yet.\r\n      if (!ctx.initialized && value === undefined) {\r\n          return true;\r\n      }\r\n      return false;\r\n  }\r\n  function createValidationCtx(ctx) {\r\n      return __assign(__assign({}, ctx.flags), { errors: ctx.messages, classes: ctx.classes, failedRules: ctx.failedRules, reset: function () { return ctx.reset(); }, validate: function () {\r\n              var args = [];\r\n              for (var _i = 0; _i < arguments.length; _i++) {\r\n                  args[_i] = arguments[_i];\r\n              }\r\n              return ctx.validate.apply(ctx, args);\r\n          }, ariaInput: {\r\n              'aria-invalid': ctx.flags.invalid ? 'true' : 'false',\r\n              'aria-required': ctx.isRequired ? 'true' : 'false',\r\n              'aria-errormessage': \"vee_\" + ctx.id\r\n          }, ariaMsg: {\r\n              id: \"vee_\" + ctx.id,\r\n              'aria-live': ctx.messages.length ? 'assertive' : 'off'\r\n          } });\r\n  }\r\n  function onRenderUpdate(vm, value) {\r\n      if (value === undefined) {\r\n          return;\r\n      }\r\n      if (!vm.initialized) {\r\n          vm.initialValue = value;\r\n      }\r\n      var validateNow = shouldValidate(vm, value);\r\n      vm._needsValidation = false;\r\n      vm.value = value;\r\n      vm._ignoreImmediate = true;\r\n      if (!validateNow) {\r\n          return;\r\n      }\r\n      vm.validateSilent().then(vm.immediate || vm.flags.validated ? vm.applyResult : identity);\r\n  }\r\n  function computeModeSetting(ctx) {\r\n      var compute = (isCallable(ctx.mode) ? ctx.mode : modes[ctx.mode]);\r\n      return compute({\r\n          errors: ctx.messages,\r\n          value: ctx.value,\r\n          flags: ctx.flags\r\n      });\r\n  }\r\n  // Creates the common handlers for a validatable context.\r\n  function createCommonHandlers(vm) {\r\n      if (!vm.$veeOnInput) {\r\n          vm.$veeOnInput = function (e) {\r\n              vm.syncValue(e); // track and keep the value updated.\r\n              vm.setFlags({ dirty: true, pristine: false });\r\n          };\r\n      }\r\n      var onInput = vm.$veeOnInput;\r\n      if (!vm.$veeOnBlur) {\r\n          vm.$veeOnBlur = function () {\r\n              vm.setFlags({ touched: true, untouched: false });\r\n          };\r\n      }\r\n      // Blur event listener.\r\n      var onBlur = vm.$veeOnBlur;\r\n      var onValidate = vm.$veeHandler;\r\n      var mode = computeModeSetting(vm);\r\n      // Handle debounce changes.\r\n      if (!onValidate || vm.$veeDebounce !== vm.debounce) {\r\n          onValidate = debounce(function () {\r\n              vm.$nextTick(function () {\r\n                  var pendingPromise = vm.validateSilent();\r\n                  // avoids race conditions between successive validations.\r\n                  vm._pendingValidation = pendingPromise;\r\n                  pendingPromise.then(function (result) {\r\n                      if (pendingPromise === vm._pendingValidation) {\r\n                          vm.applyResult(result);\r\n                          vm._pendingValidation = undefined;\r\n                      }\r\n                  });\r\n              });\r\n          }, mode.debounce || vm.debounce);\r\n          // Cache the handler so we don't create it each time.\r\n          vm.$veeHandler = onValidate;\r\n          // cache the debounce value so we detect if it was changed.\r\n          vm.$veeDebounce = vm.debounce;\r\n      }\r\n      return { onInput: onInput, onBlur: onBlur, onValidate: onValidate };\r\n  }\r\n  // Adds all plugin listeners to the vnode.\r\n  function addListeners(vm, node) {\r\n      var value = findValue(node);\r\n      // cache the input eventName.\r\n      vm._inputEventName = vm._inputEventName || getInputEventName(node, findModel(node));\r\n      onRenderUpdate(vm, value && value.value);\r\n      var _a = createCommonHandlers(vm), onInput = _a.onInput, onBlur = _a.onBlur, onValidate = _a.onValidate;\r\n      addVNodeListener(node, vm._inputEventName, onInput);\r\n      addVNodeListener(node, 'blur', onBlur);\r\n      // add the validation listeners.\r\n      vm.normalizedEvents.forEach(function (evt) {\r\n          addVNodeListener(node, evt, onValidate);\r\n      });\r\n      vm.initialized = true;\r\n  }\n\n  var PROVIDER_COUNTER = 0;\r\n  function data() {\r\n      var messages = [];\r\n      var defaultValues = {\r\n          messages: messages,\r\n          value: undefined,\r\n          initialized: false,\r\n          initialValue: undefined,\r\n          flags: createFlags(),\r\n          failedRules: {},\r\n          isDeactivated: false,\r\n          id: ''\r\n      };\r\n      return defaultValues;\r\n  }\r\n  var ValidationProvider = Vue.extend({\r\n      inject: {\r\n          $_veeObserver: {\r\n              from: '$_veeObserver',\r\n              default: function () {\r\n                  if (!this.$vnode.context.$_veeObserver) {\r\n                      this.$vnode.context.$_veeObserver = createObserver();\r\n                  }\r\n                  return this.$vnode.context.$_veeObserver;\r\n              }\r\n          }\r\n      },\r\n      props: {\r\n          vid: {\r\n              type: String,\r\n              default: ''\r\n          },\r\n          name: {\r\n              type: String,\r\n              default: null\r\n          },\r\n          mode: {\r\n              type: [String, Function],\r\n              default: function () {\r\n                  return getConfig().mode;\r\n              }\r\n          },\r\n          rules: {\r\n              type: [Object, String],\r\n              default: null\r\n          },\r\n          immediate: {\r\n              type: Boolean,\r\n              default: false\r\n          },\r\n          persist: {\r\n              type: Boolean,\r\n              default: false\r\n          },\r\n          bails: {\r\n              type: Boolean,\r\n              default: function () { return getConfig().bails; }\r\n          },\r\n          skipIfEmpty: {\r\n              type: Boolean,\r\n              default: function () { return getConfig().skipOptional; }\r\n          },\r\n          debounce: {\r\n              type: Number,\r\n              default: 0\r\n          },\r\n          tag: {\r\n              type: String,\r\n              default: 'span'\r\n          },\r\n          slim: {\r\n              type: Boolean,\r\n              default: false\r\n          },\r\n          disabled: {\r\n              type: Boolean,\r\n              default: false\r\n          },\r\n          customMessages: {\r\n              type: Object,\r\n              default: function () {\r\n                  return {};\r\n              }\r\n          }\r\n      },\r\n      watch: {\r\n          rules: {\r\n              deep: true,\r\n              handler: function (val, oldVal) {\r\n                  this._needsValidation = !isEqual(val, oldVal);\r\n              }\r\n          }\r\n      },\r\n      data: data,\r\n      computed: {\r\n          fieldDeps: function () {\r\n              var _this = this;\r\n              return Object.keys(this.normalizedRules)\r\n                  .filter(RuleContainer.isTargetRule)\r\n                  .reduce(function (acc, rule) {\r\n                  var deps = RuleContainer.getTargetParamNames(rule, _this.normalizedRules[rule]);\r\n                  acc.push.apply(acc, deps);\r\n                  deps.forEach(function (depName) {\r\n                      watchCrossFieldDep(_this, depName);\r\n                  });\r\n                  return acc;\r\n              }, []);\r\n          },\r\n          normalizedEvents: function () {\r\n              var _this = this;\r\n              var on = computeModeSetting(this).on;\r\n              return (on || []).map(function (e) {\r\n                  if (e === 'input') {\r\n                      return _this._inputEventName;\r\n                  }\r\n                  return e;\r\n              });\r\n          },\r\n          isRequired: function () {\r\n              var rules = __assign(__assign({}, this._resolvedRules), this.normalizedRules);\r\n              var isRequired = Object.keys(rules).some(RuleContainer.isRequireRule);\r\n              this.flags.required = !!isRequired;\r\n              return isRequired;\r\n          },\r\n          classes: function () {\r\n              var names = getConfig().classes;\r\n              return computeClassObj(names, this.flags);\r\n          },\r\n          normalizedRules: function () {\r\n              return normalizeRules(this.rules);\r\n          }\r\n      },\r\n      render: function (h) {\r\n          var _this = this;\r\n          this.registerField();\r\n          var ctx = createValidationCtx(this);\r\n          var children = normalizeChildren(this, ctx);\r\n          // Handle single-root slot.\r\n          extractVNodes(children).forEach(function (input) {\r\n              _this._resolvedRules = getConfig().useConstraintAttrs ? resolveRules(input) : {};\r\n              addListeners(_this, input);\r\n          });\r\n          return this.slim && children.length <= 1 ? children[0] : h(this.tag, children);\r\n      },\r\n      beforeDestroy: function () {\r\n          // cleanup reference.\r\n          this.$_veeObserver.unsubscribe(this.id);\r\n      },\r\n      activated: function () {\r\n          this.$_veeObserver.subscribe(this);\r\n          this.isDeactivated = false;\r\n      },\r\n      deactivated: function () {\r\n          this.$_veeObserver.unsubscribe(this.id);\r\n          this.isDeactivated = true;\r\n      },\r\n      methods: {\r\n          setFlags: function (flags) {\r\n              var _this = this;\r\n              Object.keys(flags).forEach(function (flag) {\r\n                  _this.flags[flag] = flags[flag];\r\n              });\r\n          },\r\n          syncValue: function (v) {\r\n              var value = normalizeEventValue(v);\r\n              this.value = value;\r\n              this.flags.changed = this.initialValue !== value;\r\n          },\r\n          reset: function () {\r\n              this.messages = [];\r\n              this.initialValue = this.value;\r\n              var flags = createFlags();\r\n              flags.required = this.isRequired;\r\n              this.setFlags(flags);\r\n              this.validateSilent();\r\n          },\r\n          validate: function () {\r\n              var args = [];\r\n              for (var _i = 0; _i < arguments.length; _i++) {\r\n                  args[_i] = arguments[_i];\r\n              }\r\n              return __awaiter(this, void 0, void 0, function () {\r\n                  var result;\r\n                  return __generator(this, function (_a) {\r\n                      switch (_a.label) {\r\n                          case 0:\r\n                              if (args.length > 0) {\r\n                                  this.syncValue(args[0]);\r\n                              }\r\n                              return [4 /*yield*/, this.validateSilent()];\r\n                          case 1:\r\n                              result = _a.sent();\r\n                              this.applyResult(result);\r\n                              return [2 /*return*/, result];\r\n                      }\r\n                  });\r\n              });\r\n          },\r\n          validateSilent: function () {\r\n              return __awaiter(this, void 0, void 0, function () {\r\n                  var rules, result;\r\n                  return __generator(this, function (_a) {\r\n                      switch (_a.label) {\r\n                          case 0:\r\n                              this.setFlags({ pending: true });\r\n                              rules = __assign(__assign({}, this._resolvedRules), this.normalizedRules);\r\n                              Object.defineProperty(rules, '_$$isNormalized', {\r\n                                  value: true,\r\n                                  writable: false,\r\n                                  enumerable: false,\r\n                                  configurable: false\r\n                              });\r\n                              return [4 /*yield*/, validate$r(this.value, rules, {\r\n                                      name: this.name,\r\n                                      values: createValuesLookup(this),\r\n                                      bails: this.bails,\r\n                                      skipIfEmpty: this.skipIfEmpty,\r\n                                      isInitial: !this.initialized,\r\n                                      customMessages: this.customMessages\r\n                                  })];\r\n                          case 1:\r\n                              result = _a.sent();\r\n                              this.setFlags({ pending: false });\r\n                              this.setFlags({ valid: result.valid, invalid: !result.valid });\r\n                              return [2 /*return*/, result];\r\n                      }\r\n                  });\r\n              });\r\n          },\r\n          setErrors: function (errors) {\r\n              this.applyResult({ errors: errors, failedRules: {} });\r\n          },\r\n          applyResult: function (_a) {\r\n              var errors = _a.errors, failedRules = _a.failedRules;\r\n              this.messages = errors;\r\n              this.failedRules = __assign({}, (failedRules || {}));\r\n              this.setFlags({\r\n                  valid: !errors.length,\r\n                  changed: this.value !== this.initialValue,\r\n                  invalid: !!errors.length,\r\n                  validated: true\r\n              });\r\n          },\r\n          registerField: function () {\r\n              updateRenderingContextRefs(this);\r\n          }\r\n      }\r\n  });\r\n  function createValuesLookup(vm) {\r\n      var providers = vm.$_veeObserver.refs;\r\n      var reduced = {};\r\n      return vm.fieldDeps.reduce(function (acc, depName) {\r\n          if (!providers[depName]) {\r\n              return acc;\r\n          }\r\n          acc[depName] = providers[depName].value;\r\n          return acc;\r\n      }, reduced);\r\n  }\r\n  function extractId(vm) {\r\n      if (vm.vid) {\r\n          return vm.vid;\r\n      }\r\n      if (vm.name) {\r\n          return vm.name;\r\n      }\r\n      if (vm.id) {\r\n          return vm.id;\r\n      }\r\n      PROVIDER_COUNTER++;\r\n      return \"_vee_\" + PROVIDER_COUNTER;\r\n  }\r\n  function updateRenderingContextRefs(vm) {\r\n      var providedId = extractId(vm);\r\n      var id = vm.id;\r\n      // Nothing has changed.\r\n      if (vm.isDeactivated || (id === providedId && vm.$_veeObserver.refs[id])) {\r\n          return;\r\n      }\r\n      // vid was changed.\r\n      if (id !== providedId && vm.$_veeObserver.refs[id] === vm) {\r\n          vm.$_veeObserver.unsubscribe(id);\r\n      }\r\n      vm.id = providedId;\r\n      vm.$_veeObserver.subscribe(vm);\r\n  }\r\n  function createObserver() {\r\n      return {\r\n          refs: {},\r\n          subscribe: function (vm) {\r\n              this.refs[vm.id] = vm;\r\n          },\r\n          unsubscribe: function (id) {\r\n              delete this.refs[id];\r\n          }\r\n      };\r\n  }\r\n  function watchCrossFieldDep(ctx, depName, withHooks) {\r\n      if (withHooks === void 0) { withHooks = true; }\r\n      var providers = ctx.$_veeObserver.refs;\r\n      if (!ctx._veeWatchers) {\r\n          ctx._veeWatchers = {};\r\n      }\r\n      if (!providers[depName] && withHooks) {\r\n          return ctx.$once('hook:mounted', function () {\r\n              watchCrossFieldDep(ctx, depName, false);\r\n          });\r\n      }\r\n      if (!isCallable(ctx._veeWatchers[depName]) && providers[depName]) {\r\n          ctx._veeWatchers[depName] = providers[depName].$watch('value', function () {\r\n              if (ctx.flags.validated) {\r\n                  ctx._needsValidation = true;\r\n                  ctx.validate();\r\n              }\r\n          });\r\n      }\r\n  }\n\n  var flagMergingStrategy = {\r\n      pristine: 'every',\r\n      dirty: 'some',\r\n      touched: 'some',\r\n      untouched: 'every',\r\n      valid: 'every',\r\n      invalid: 'some',\r\n      pending: 'some',\r\n      validated: 'every',\r\n      changed: 'some'\r\n  };\r\n  function mergeFlags(lhs, rhs, strategy) {\r\n      var stratName = flagMergingStrategy[strategy];\r\n      return [lhs, rhs][stratName](function (f) { return f; });\r\n  }\r\n  var OBSERVER_COUNTER = 0;\r\n  function data$1() {\r\n      var refs = {};\r\n      var refsByName = {};\r\n      var inactiveRefs = {};\r\n      // FIXME: Not sure of this one can be typed, circular type reference.\r\n      var observers = [];\r\n      return {\r\n          id: '',\r\n          refs: refs,\r\n          refsByName: refsByName,\r\n          observers: observers,\r\n          inactiveRefs: inactiveRefs\r\n      };\r\n  }\r\n  var ValidationObserver = Vue.extend({\r\n      name: 'ValidationObserver',\r\n      provide: function () {\r\n          return {\r\n              $_veeObserver: this\r\n          };\r\n      },\r\n      inject: {\r\n          $_veeObserver: {\r\n              from: '$_veeObserver',\r\n              default: function () {\r\n                  if (!this.$vnode.context.$_veeObserver) {\r\n                      return null;\r\n                  }\r\n                  return this.$vnode.context.$_veeObserver;\r\n              }\r\n          }\r\n      },\r\n      props: {\r\n          tag: {\r\n              type: String,\r\n              default: 'span'\r\n          },\r\n          vid: {\r\n              type: String,\r\n              default: function () {\r\n                  return \"obs_\" + OBSERVER_COUNTER++;\r\n              }\r\n          },\r\n          slim: {\r\n              type: Boolean,\r\n              default: false\r\n          },\r\n          disabled: {\r\n              type: Boolean,\r\n              default: false\r\n          }\r\n      },\r\n      data: data$1,\r\n      computed: {\r\n          ctx: function () {\r\n              var _this = this;\r\n              var ctx = {\r\n                  errors: {},\r\n                  passes: function (cb) {\r\n                      return _this.validate().then(function (result) {\r\n                          if (result) {\r\n                              return cb();\r\n                          }\r\n                      });\r\n                  },\r\n                  validate: function () {\r\n                      var args = [];\r\n                      for (var _i = 0; _i < arguments.length; _i++) {\r\n                          args[_i] = arguments[_i];\r\n                      }\r\n                      return _this.validate.apply(_this, args);\r\n                  },\r\n                  reset: function () { return _this.reset(); }\r\n              };\r\n              return __spreadArrays(values(this.refs), Object.keys(this.inactiveRefs).map(function (key) {\r\n                  return {\r\n                      vid: key,\r\n                      flags: _this.inactiveRefs[key].flags,\r\n                      messages: _this.inactiveRefs[key].errors\r\n                  };\r\n              }), this.observers).reduce(function (acc, provider) {\r\n                  Object.keys(flagMergingStrategy).forEach(function (flag) {\r\n                      var flags = provider.flags || provider.ctx;\r\n                      if (!(flag in acc)) {\r\n                          acc[flag] = flags[flag];\r\n                          return;\r\n                      }\r\n                      acc[flag] = mergeFlags(acc[flag], flags[flag], flag);\r\n                  });\r\n                  acc.errors[provider.id] =\r\n                      provider.messages ||\r\n                          values(provider.ctx.errors).reduce(function (errs, obsErrors) {\r\n                              return errs.concat(obsErrors);\r\n                          }, []);\r\n                  return acc;\r\n              }, ctx);\r\n          }\r\n      },\r\n      created: function () {\r\n          this.id = this.vid;\r\n          if (this.$_veeObserver) {\r\n              this.$_veeObserver.subscribe(this, 'observer');\r\n          }\r\n      },\r\n      activated: function () {\r\n          if (this.$_veeObserver) {\r\n              this.$_veeObserver.subscribe(this, 'observer');\r\n          }\r\n      },\r\n      deactivated: function () {\r\n          if (this.$_veeObserver) {\r\n              this.$_veeObserver.unsubscribe(this.id, 'observer');\r\n          }\r\n      },\r\n      beforeDestroy: function () {\r\n          if (this.$_veeObserver) {\r\n              this.$_veeObserver.unsubscribe(this.id, 'observer');\r\n          }\r\n      },\r\n      render: function (h) {\r\n          var children = normalizeChildren(this, this.ctx);\r\n          return this.slim && children.length <= 1 ? children[0] : h(this.tag, { on: this.$listeners }, children);\r\n      },\r\n      methods: {\r\n          subscribe: function (subscriber, kind) {\r\n              var _a, _b;\r\n              if (kind === void 0) { kind = 'provider'; }\r\n              if (kind === 'observer') {\r\n                  this.observers.push(subscriber);\r\n                  return;\r\n              }\r\n              this.refs = __assign(__assign({}, this.refs), (_a = {}, _a[subscriber.id] = subscriber, _a));\r\n              this.refsByName = __assign(__assign({}, this.refsByName), (_b = {}, _b[subscriber.name] = subscriber, _b));\r\n              if (subscriber.persist) {\r\n                  this.restoreProviderState(subscriber);\r\n              }\r\n          },\r\n          unsubscribe: function (id, kind) {\r\n              if (kind === void 0) { kind = 'provider'; }\r\n              if (kind === 'provider') {\r\n                  this.removeProvider(id);\r\n                  return;\r\n              }\r\n              var idx = findIndex(this.observers, function (o) { return o.id === id; });\r\n              if (idx !== -1) {\r\n                  this.observers.splice(idx, 1);\r\n              }\r\n          },\r\n          validate: function (_a) {\r\n              var _b = (_a === void 0 ? {} : _a).silent, silent = _b === void 0 ? false : _b;\r\n              return __awaiter(this, void 0, void 0, function () {\r\n                  var results;\r\n                  return __generator(this, function (_c) {\r\n                      switch (_c.label) {\r\n                          case 0: return [4 /*yield*/, Promise.all(__spreadArrays(values(this.refs)\r\n                                  .filter(function (r) { return !r.disabled; })\r\n                                  .map(function (ref) { return ref[silent ? 'validateSilent' : 'validate']().then(function (r) { return r.valid; }); }), this.observers.filter(function (o) { return !o.disabled; }).map(function (obs) { return obs.validate({ silent: silent }); })))];\r\n                          case 1:\r\n                              results = _c.sent();\r\n                              return [2 /*return*/, results.every(function (r) { return r; })];\r\n                      }\r\n                  });\r\n              });\r\n          },\r\n          reset: function () {\r\n              var _this = this;\r\n              Object.keys(this.inactiveRefs).forEach(function (key) {\r\n                  _this.$delete(_this.inactiveRefs, key);\r\n              });\r\n              return __spreadArrays(values(this.refs), this.observers).forEach(function (ref) { return ref.reset(); });\r\n          },\r\n          restoreProviderState: function (provider) {\r\n              var id = provider.id;\r\n              var state = this.inactiveRefs[id];\r\n              if (!state) {\r\n                  return;\r\n              }\r\n              provider.setFlags(state.flags);\r\n              provider.applyResult(state);\r\n              this.$delete(this.inactiveRefs, provider.id);\r\n          },\r\n          removeProvider: function (id) {\r\n              var provider = this.refs[id];\r\n              if (!provider) {\r\n                  // FIXME: inactive refs are not being cleaned up.\r\n                  return;\r\n              }\r\n              if (provider.persist) {\r\n                  // save it for the next time.\r\n                  this.inactiveRefs[id] = {\r\n                      flags: provider.flags,\r\n                      errors: provider.messages,\r\n                      failedRules: provider.failedRules\r\n                  };\r\n              }\r\n              this.$delete(this.refs, id);\r\n              this.$delete(this.refsByName, provider.name);\r\n          },\r\n          setErrors: function (errors) {\r\n              var _this = this;\r\n              Object.keys(errors).forEach(function (key) {\r\n                  var provider = _this.refs[key] || _this.refsByName[key];\r\n                  if (!provider)\r\n                      return;\r\n                  provider.setErrors(errors[key] || []);\r\n              });\r\n              this.observers.forEach(function (observer) {\r\n                  observer.setErrors(errors);\r\n              });\r\n          }\r\n      }\r\n  });\n\n  function withValidation(component, mapProps) {\r\n      if (mapProps === void 0) { mapProps = identity; }\r\n      var options = 'options' in component ? component.options : component;\r\n      var providerOpts = ValidationProvider.options;\r\n      var hoc = {\r\n          name: (options.name || 'AnonymousHoc') + \"WithValidation\",\r\n          props: __assign({}, providerOpts.props),\r\n          data: providerOpts.data,\r\n          computed: __assign({}, providerOpts.computed),\r\n          methods: __assign({}, providerOpts.methods),\r\n          beforeDestroy: providerOpts.beforeDestroy,\r\n          inject: providerOpts.inject\r\n      };\r\n      var eventName = (options.model && options.model.event) || 'input';\r\n      hoc.render = function (h) {\r\n          var _a;\r\n          this.registerField();\r\n          var vctx = createValidationCtx(this);\r\n          var listeners = __assign({}, this.$listeners);\r\n          var model = findModel(this.$vnode);\r\n          this._inputEventName = this._inputEventName || getInputEventName(this.$vnode, model);\r\n          var value = findValue(this.$vnode);\r\n          onRenderUpdate(this, value && value.value);\r\n          var _b = createCommonHandlers(this), onInput = _b.onInput, onBlur = _b.onBlur, onValidate = _b.onValidate;\r\n          mergeVNodeListeners(listeners, eventName, onInput);\r\n          mergeVNodeListeners(listeners, 'blur', onBlur);\r\n          this.normalizedEvents.forEach(function (evt) {\r\n              mergeVNodeListeners(listeners, evt, onValidate);\r\n          });\r\n          // Props are any attrs not associated with ValidationProvider Plus the model prop.\r\n          // WARNING: Accidental prop overwrite will probably happen.\r\n          var prop = (findModelConfig(this.$vnode) || { prop: 'value' }).prop;\r\n          var props = __assign(__assign(__assign({}, this.$attrs), (_a = {}, _a[prop] = model && model.value, _a)), mapProps(vctx));\r\n          return h(options, {\r\n              attrs: this.$attrs,\r\n              props: props,\r\n              on: listeners\r\n          }, normalizeSlots(this.$slots, this.$vnode.context));\r\n      };\r\n      return hoc;\r\n  }\n\n  var version = '3.0.8';\r\n  // Install all rules.\r\n  var RulesAsList = Object.keys(Rules).map(function (key) { return ({ schema: Rules[key], name: key }); });\r\n  RulesAsList.forEach(function (_a) {\r\n      var name = _a.name, schema = _a.schema;\r\n      extend(name, schema);\r\n  });\r\n  // Install locale\r\n  localize('en', en);\n\n  exports.Rules = Rules;\n  exports.ValidationObserver = ValidationObserver;\n  exports.ValidationProvider = ValidationProvider;\n  exports.configure = configure;\n  exports.extend = extend;\n  exports.install = install;\n  exports.localize = localize;\n  exports.setInteractionMode = setInteractionMode;\n  exports.validate = validate$r;\n  exports.version = version;\n  exports.withValidation = withValidation;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdmVlLXZhbGlkYXRlL2Rpc3QvdmVlLXZhbGlkYXRlLmZ1bGwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmVlLXZhbGlkYXRlL2Rpc3QvdmVlLXZhbGlkYXRlLmZ1bGwuanM/MDM5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAgKiB2ZWUtdmFsaWRhdGUgdjMuMC44XG4gICogKGMpIDIwMTkgQWJkZWxyYWhtYW4gQXdhZFxuICAqIEBsaWNlbnNlIE1JVFxuICAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCd2dWUnKSkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ3Z1ZSddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuVmVlVmFsaWRhdGUgPSB7fSwgZ2xvYmFsLlZ1ZSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cywgVnVlKSB7ICd1c2Ugc3RyaWN0JztcblxuICBWdWUgPSBWdWUgJiYgVnVlLmhhc093blByb3BlcnR5KCdkZWZhdWx0JykgPyBWdWVbJ2RlZmF1bHQnXSA6IFZ1ZTtcblxuICB2YXIgY29kZSA9IFwiZW5cIjtcbiAgdmFyIG1lc3NhZ2VzID0ge1xuICBcdGFscGhhOiBcIlRoZSB7X2ZpZWxkX30gZmllbGQgbWF5IG9ubHkgY29udGFpbiBhbHBoYWJldGljIGNoYXJhY3RlcnNcIixcbiAgXHRhbHBoYV9udW06IFwiVGhlIHtfZmllbGRffSBmaWVsZCBtYXkgb25seSBjb250YWluIGFscGhhLW51bWVyaWMgY2hhcmFjdGVyc1wiLFxuICBcdGFscGhhX2Rhc2g6IFwiVGhlIHtfZmllbGRffSBmaWVsZCBtYXkgY29udGFpbiBhbHBoYS1udW1lcmljIGNoYXJhY3RlcnMgYXMgd2VsbCBhcyBkYXNoZXMgYW5kIHVuZGVyc2NvcmVzXCIsXG4gIFx0YWxwaGFfc3BhY2VzOiBcIlRoZSB7X2ZpZWxkX30gZmllbGQgbWF5IG9ubHkgY29udGFpbiBhbHBoYWJldGljIGNoYXJhY3RlcnMgYXMgd2VsbCBhcyBzcGFjZXNcIixcbiAgXHRiZXR3ZWVuOiBcIlRoZSB7X2ZpZWxkX30gZmllbGQgbXVzdCBiZSBiZXR3ZWVuIHttaW59IGFuZCB7bWF4fVwiLFxuICBcdGNvbmZpcm1lZDogXCJUaGUge19maWVsZF99IGZpZWxkIGNvbmZpcm1hdGlvbiBkb2VzIG5vdCBtYXRjaFwiLFxuICBcdGRpZ2l0czogXCJUaGUge19maWVsZF99IGZpZWxkIG11c3QgYmUgbnVtZXJpYyBhbmQgZXhhY3RseSBjb250YWluIHtsZW5ndGh9IGRpZ2l0c1wiLFxuICBcdGRpbWVuc2lvbnM6IFwiVGhlIHtfZmllbGRffSBmaWVsZCBtdXN0IGJlIHt3aWR0aH0gcGl4ZWxzIGJ5IHtoZWlnaHR9IHBpeGVsc1wiLFxuICBcdGVtYWlsOiBcIlRoZSB7X2ZpZWxkX30gZmllbGQgbXVzdCBiZSBhIHZhbGlkIGVtYWlsXCIsXG4gIFx0ZXhjbHVkZWQ6IFwiVGhlIHtfZmllbGRffSBmaWVsZCBpcyBub3QgYSB2YWxpZCB2YWx1ZVwiLFxuICBcdGV4dDogXCJUaGUge19maWVsZF99IGZpZWxkIGlzIG5vdCBhIHZhbGlkIGZpbGVcIixcbiAgXHRpbWFnZTogXCJUaGUge19maWVsZF99IGZpZWxkIG11c3QgYmUgYW4gaW1hZ2VcIixcbiAgXHRpbnRlZ2VyOiBcIlRoZSB7X2ZpZWxkX30gZmllbGQgbXVzdCBiZSBhbiBpbnRlZ2VyXCIsXG4gIFx0bGVuZ3RoOiBcIlRoZSB7X2ZpZWxkX30gZmllbGQgbXVzdCBiZSB7bGVuZ3RofSBsb25nXCIsXG4gIFx0bWF4X3ZhbHVlOiBcIlRoZSB7X2ZpZWxkX30gZmllbGQgbXVzdCBiZSB7bWF4fSBvciBsZXNzXCIsXG4gIFx0bWF4OiBcIlRoZSB7X2ZpZWxkX30gZmllbGQgbWF5IG5vdCBiZSBncmVhdGVyIHRoYW4ge2xlbmd0aH0gY2hhcmFjdGVyc1wiLFxuICBcdG1pbWVzOiBcIlRoZSB7X2ZpZWxkX30gZmllbGQgbXVzdCBoYXZlIGEgdmFsaWQgZmlsZSB0eXBlXCIsXG4gIFx0bWluX3ZhbHVlOiBcIlRoZSB7X2ZpZWxkX30gZmllbGQgbXVzdCBiZSB7bWlufSBvciBtb3JlXCIsXG4gIFx0bWluOiBcIlRoZSB7X2ZpZWxkX30gZmllbGQgbXVzdCBiZSBhdCBsZWFzdCB7bGVuZ3RofSBjaGFyYWN0ZXJzXCIsXG4gIFx0bnVtZXJpYzogXCJUaGUge19maWVsZF99IGZpZWxkIG1heSBvbmx5IGNvbnRhaW4gbnVtZXJpYyBjaGFyYWN0ZXJzXCIsXG4gIFx0b25lT2Y6IFwiVGhlIHtfZmllbGRffSBmaWVsZCBpcyBub3QgYSB2YWxpZCB2YWx1ZVwiLFxuICBcdHJlZ2V4OiBcIlRoZSB7X2ZpZWxkX30gZmllbGQgZm9ybWF0IGlzIGludmFsaWRcIixcbiAgXHRyZXF1aXJlZF9pZjogXCJUaGUge19maWVsZF99IGZpZWxkIGlzIHJlcXVpcmVkXCIsXG4gIFx0cmVxdWlyZWQ6IFwiVGhlIHtfZmllbGRffSBmaWVsZCBpcyByZXF1aXJlZFwiLFxuICBcdHNpemU6IFwiVGhlIHtfZmllbGRffSBmaWVsZCBzaXplIG11c3QgYmUgbGVzcyB0aGFuIHtzaXplfUtCXCJcbiAgfTtcbiAgdmFyIGVuID0ge1xuICBcdGNvZGU6IGNvZGUsXG4gIFx0bWVzc2FnZXM6IG1lc3NhZ2VzXG4gIH07XG5cbiAgLyoqXHJcbiAgICogU29tZSBBbHBoYSBSZWdleCBoZWxwZXJzLlxyXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaHJpc28vdmFsaWRhdG9yLmpzL2Jsb2IvbWFzdGVyL3NyYy9saWIvYWxwaGEuanNcclxuICAgKi9cclxuICB2YXIgYWxwaGEgPSB7XHJcbiAgICAgIGVuOiAvXltBLVpdKiQvaSxcclxuICAgICAgY3M6IC9eW0EtWsOBxIzEjsOJxJrDjcWHw5PFmMWgxaTDmsWuw53FvV0qJC9pLFxyXG4gICAgICBkYTogL15bQS1aw4bDmMOFXSokL2ksXHJcbiAgICAgIGRlOiAvXltBLVrDhMOWw5zDn10qJC9pLFxyXG4gICAgICBlczogL15bQS1aw4HDicONw5HDk8Oaw5xdKiQvaSxcclxuICAgICAgZnI6IC9eW0EtWsOAw4LDhsOHw4nDiMOKw4vDj8OOw5TFksOZw5vDnMW4XSokL2ksXHJcbiAgICAgIGl0OiAvXltBLVpcXHhDMC1cXHhGRl0qJC9pLFxyXG4gICAgICBsdDogL15bQS1axITEjMSYxJbErsWgxbLFqsW9XSokL2ksXHJcbiAgICAgIG5sOiAvXltBLVrDicOLw4/Dk8OWw5xdKiQvaSxcclxuICAgICAgaHU6IC9eW0EtWsOBw4nDjcOTw5bFkMOaw5zFsF0qJC9pLFxyXG4gICAgICBwbDogL15bQS1axITEhsSYxZrFgcWDw5PFu8W5XSokL2ksXHJcbiAgICAgIHB0OiAvXltBLVrDg8OBw4DDgsOHw4nDisONw5XDk8OUw5rDnF0qJC9pLFxyXG4gICAgICBydTogL15b0JAt0K/QgV0qJC9pLFxyXG4gICAgICBzazogL15bQS1aw4HDhMSMxI7DicONxLnEvcWHw5PFlMWgxaTDmsOdxb1dKiQvaSxcclxuICAgICAgc3I6IC9eW0EtWsSMxIbFvcWgxJBdKiQvaSxcclxuICAgICAgc3Y6IC9eW0EtWsOFw4TDll0qJC9pLFxyXG4gICAgICB0cjogL15bQS1aw4fEnsSwxLHDlsWew5xdKiQvaSxcclxuICAgICAgdWs6IC9eW9CQLdCp0KzQrtCv0ITQhtCH0pBdKiQvaSxcclxuICAgICAgYXI6IC9eW9ih2KLYo9ik2KXYptin2KjYqdiq2KvYrNit2K7Yr9iw2LHYstiz2LTYtdi22LfYuNi52LrZgdmC2YPZhNmF2YbZh9mI2YnZitmL2YzZjdmO2Y/ZkNmR2ZLZsF0qJC8sXHJcbiAgICAgIGF6OiAvXltBLVrDh8aPxJ7EsMSxw5bFnsOcXSokL2lcclxuICB9O1xyXG4gIHZhciBhbHBoYVNwYWNlcyA9IHtcclxuICAgICAgZW46IC9eW0EtWlxcc10qJC9pLFxyXG4gICAgICBjczogL15bQS1aw4HEjMSOw4nEmsONxYfDk8WYxaDFpMOaxa7DncW9XFxzXSokL2ksXHJcbiAgICAgIGRhOiAvXltBLVrDhsOYw4VcXHNdKiQvaSxcclxuICAgICAgZGU6IC9eW0EtWsOEw5bDnMOfXFxzXSokL2ksXHJcbiAgICAgIGVzOiAvXltBLVrDgcOJw43DkcOTw5rDnFxcc10qJC9pLFxyXG4gICAgICBmcjogL15bQS1aw4DDgsOGw4fDicOIw4rDi8OPw47DlMWSw5nDm8OcxbhcXHNdKiQvaSxcclxuICAgICAgaXQ6IC9eW0EtWlxceEMwLVxceEZGXFxzXSokL2ksXHJcbiAgICAgIGx0OiAvXltBLVrEhMSMxJjElsSuxaDFssWqxb1cXHNdKiQvaSxcclxuICAgICAgbmw6IC9eW0EtWsOJw4vDj8OTw5bDnFxcc10qJC9pLFxyXG4gICAgICBodTogL15bQS1aw4HDicONw5PDlsWQw5rDnMWwXFxzXSokL2ksXHJcbiAgICAgIHBsOiAvXltBLVrEhMSGxJjFmsWBxYPDk8W7xblcXHNdKiQvaSxcclxuICAgICAgcHQ6IC9eW0EtWsODw4HDgMOCw4fDicOKw43DlcOTw5TDmsOcXFxzXSokL2ksXHJcbiAgICAgIHJ1OiAvXlvQkC3Qr9CBXFxzXSokL2ksXHJcbiAgICAgIHNrOiAvXltBLVrDgcOExIzEjsOJw43EucS9xYfDk8WUxaDFpMOaw53FvVxcc10qJC9pLFxyXG4gICAgICBzcjogL15bQS1axIzEhsW9xaDEkFxcc10qJC9pLFxyXG4gICAgICBzdjogL15bQS1aw4XDhMOWXFxzXSokL2ksXHJcbiAgICAgIHRyOiAvXltBLVrDh8SexLDEscOWxZ7DnFxcc10qJC9pLFxyXG4gICAgICB1azogL15b0JAt0KnQrNCu0K/QhNCG0IfSkFxcc10qJC9pLFxyXG4gICAgICBhcjogL15b2KHYotij2KTYpdim2KfYqNip2KrYq9is2K3Yrtiv2LDYsdiy2LPYtNi12LbYt9i42LnYutmB2YLZg9mE2YXZhtmH2YjZidmK2YvZjNmN2Y7Zj9mQ2ZHZktmwXFxzXSokLyxcclxuICAgICAgYXo6IC9eW0EtWsOHxo/EnsSwxLHDlsWew5xcXHNdKiQvaVxyXG4gIH07XHJcbiAgdmFyIGFscGhhbnVtZXJpYyA9IHtcclxuICAgICAgZW46IC9eWzAtOUEtWl0qJC9pLFxyXG4gICAgICBjczogL15bMC05QS1aw4HEjMSOw4nEmsONxYfDk8WYxaDFpMOaxa7DncW9XSokL2ksXHJcbiAgICAgIGRhOiAvXlswLTlBLVrDhsOYw4VdJC9pLFxyXG4gICAgICBkZTogL15bMC05QS1aw4TDlsOcw59dKiQvaSxcclxuICAgICAgZXM6IC9eWzAtOUEtWsOBw4nDjcORw5PDmsOcXSokL2ksXHJcbiAgICAgIGZyOiAvXlswLTlBLVrDgMOCw4bDh8OJw4jDisOLw4/DjsOUxZLDmcObw5zFuF0qJC9pLFxyXG4gICAgICBpdDogL15bMC05QS1aXFx4QzAtXFx4RkZdKiQvaSxcclxuICAgICAgbHQ6IC9eWzAtOUEtWsSExIzEmMSWxK7FoMWyxarFvV0qJC9pLFxyXG4gICAgICBodTogL15bMC05QS1aw4HDicONw5PDlsWQw5rDnMWwXSokL2ksXHJcbiAgICAgIG5sOiAvXlswLTlBLVrDicOLw4/Dk8OWw5xdKiQvaSxcclxuICAgICAgcGw6IC9eWzAtOUEtWsSExIbEmMWaxYHFg8OTxbvFuV0qJC9pLFxyXG4gICAgICBwdDogL15bMC05QS1aw4PDgcOAw4LDh8OJw4rDjcOVw5PDlMOaw5xdKiQvaSxcclxuICAgICAgcnU6IC9eWzAtOdCQLdCv0IFdKiQvaSxcclxuICAgICAgc2s6IC9eWzAtOUEtWsOBw4TEjMSOw4nDjcS5xL3Fh8OTxZTFoMWkw5rDncW9XSokL2ksXHJcbiAgICAgIHNyOiAvXlswLTlBLVrEjMSGxb3FoMSQXSokL2ksXHJcbiAgICAgIHN2OiAvXlswLTlBLVrDhcOEw5ZdKiQvaSxcclxuICAgICAgdHI6IC9eWzAtOUEtWsOHxJ7EsMSxw5bFnsOcXSokL2ksXHJcbiAgICAgIHVrOiAvXlswLTnQkC3QqdCs0K7Qr9CE0IbQh9KQXSokL2ksXHJcbiAgICAgIGFyOiAvXlvZoNmh2aLZo9mk2aXZptmn2ajZqTAtOdih2KLYo9ik2KXYptin2KjYqdiq2KvYrNit2K7Yr9iw2LHYstiz2LTYtdi22LfYuNi52LrZgdmC2YPZhNmF2YbZh9mI2YnZitmL2YzZjdmO2Y/ZkNmR2ZLZsF0qJC8sXHJcbiAgICAgIGF6OiAvXlswLTlBLVrDh8aPxJ7EsMSxw5bFnsOcXSokL2lcclxuICB9O1xyXG4gIHZhciBhbHBoYURhc2ggPSB7XHJcbiAgICAgIGVuOiAvXlswLTlBLVpfLV0qJC9pLFxyXG4gICAgICBjczogL15bMC05QS1aw4HEjMSOw4nEmsONxYfDk8WYxaDFpMOaxa7DncW9Xy1dKiQvaSxcclxuICAgICAgZGE6IC9eWzAtOUEtWsOGw5jDhV8tXSokL2ksXHJcbiAgICAgIGRlOiAvXlswLTlBLVrDhMOWw5zDn18tXSokL2ksXHJcbiAgICAgIGVzOiAvXlswLTlBLVrDgcOJw43DkcOTw5rDnF8tXSokL2ksXHJcbiAgICAgIGZyOiAvXlswLTlBLVrDgMOCw4bDh8OJw4jDisOLw4/DjsOUxZLDmcObw5zFuF8tXSokL2ksXHJcbiAgICAgIGl0OiAvXlswLTlBLVpcXHhDMC1cXHhGRl8tXSokL2ksXHJcbiAgICAgIGx0OiAvXlswLTlBLVrEhMSMxJjElsSuxaDFssWqxb1fLV0qJC9pLFxyXG4gICAgICBubDogL15bMC05QS1aw4nDi8OPw5PDlsOcXy1dKiQvaSxcclxuICAgICAgaHU6IC9eWzAtOUEtWsOBw4nDjcOTw5bFkMOaw5zFsF8tXSokL2ksXHJcbiAgICAgIHBsOiAvXlswLTlBLVrEhMSGxJjFmsWBxYPDk8W7xblfLV0qJC9pLFxyXG4gICAgICBwdDogL15bMC05QS1aw4PDgcOAw4LDh8OJw4rDjcOVw5PDlMOaw5xfLV0qJC9pLFxyXG4gICAgICBydTogL15bMC050JAt0K/QgV8tXSokL2ksXHJcbiAgICAgIHNrOiAvXlswLTlBLVrDgcOExIzEjsOJw43EucS9xYfDk8WUxaDFpMOaw53FvV8tXSokL2ksXHJcbiAgICAgIHNyOiAvXlswLTlBLVrEjMSGxb3FoMSQXy1dKiQvaSxcclxuICAgICAgc3Y6IC9eWzAtOUEtWsOFw4TDll8tXSokL2ksXHJcbiAgICAgIHRyOiAvXlswLTlBLVrDh8SexLDEscOWxZ7DnF8tXSokL2ksXHJcbiAgICAgIHVrOiAvXlswLTnQkC3QqdCs0K7Qr9CE0IbQh9KQXy1dKiQvaSxcclxuICAgICAgYXI6IC9eW9mg2aHZotmj2aTZpdmm2afZqNmpMC052KHYotij2KTYpdim2KfYqNip2KrYq9is2K3Yrtiv2LDYsdiy2LPYtNi12LbYt9i42LnYutmB2YLZg9mE2YXZhtmH2YjZidmK2YvZjNmN2Y7Zj9mQ2ZHZktmwXy1dKiQvLFxyXG4gICAgICBhejogL15bMC05QS1aw4fGj8SexLDEscOWxZ7DnF8tXSokL2lcclxuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgX2EpIHtcclxuICAgICAgdmFyIF9iID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5sb2NhbGUsIGxvY2FsZSA9IF9iID09PSB2b2lkIDAgPyAnJyA6IF9iO1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgIHJldHVybiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWxpZGF0ZSh2YWwsIHsgbG9jYWxlOiBsb2NhbGUgfSk7IH0pO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIE1hdGNoIGF0IGxlYXN0IG9uZSBsb2NhbGUuXHJcbiAgICAgIGlmICghbG9jYWxlKSB7XHJcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoYWxwaGEpLnNvbWUoZnVuY3Rpb24gKGxvYykgeyByZXR1cm4gYWxwaGFbbG9jXS50ZXN0KHZhbHVlKTsgfSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIChhbHBoYVtsb2NhbGVdIHx8IGFscGhhLmVuKS50ZXN0KHZhbHVlKTtcclxuICB9O1xyXG4gIHZhciBwYXJhbXMgPSBbXHJcbiAgICAgIHtcclxuICAgICAgICAgIG5hbWU6ICdsb2NhbGUnXHJcbiAgICAgIH1cclxuICBdO1xyXG4gIHZhciBhbHBoYSQxID0ge1xyXG4gICAgICB2YWxpZGF0ZTogdmFsaWRhdGUsXHJcbiAgICAgIHBhcmFtczogcGFyYW1zXHJcbiAgfTtcblxuICB2YXIgdmFsaWRhdGUkMSA9IGZ1bmN0aW9uICh2YWx1ZSwgX2EpIHtcclxuICAgICAgdmFyIF9iID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5sb2NhbGUsIGxvY2FsZSA9IF9iID09PSB2b2lkIDAgPyAnJyA6IF9iO1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgIHJldHVybiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWxpZGF0ZSQxKHZhbCwgeyBsb2NhbGU6IGxvY2FsZSB9KTsgfSk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gTWF0Y2ggYXQgbGVhc3Qgb25lIGxvY2FsZS5cclxuICAgICAgaWYgKCFsb2NhbGUpIHtcclxuICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhhbHBoYURhc2gpLnNvbWUoZnVuY3Rpb24gKGxvYykgeyByZXR1cm4gYWxwaGFEYXNoW2xvY10udGVzdCh2YWx1ZSk7IH0pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAoYWxwaGFEYXNoW2xvY2FsZV0gfHwgYWxwaGFEYXNoLmVuKS50ZXN0KHZhbHVlKTtcclxuICB9O1xyXG4gIHZhciBwYXJhbXMkMSA9IFtcclxuICAgICAge1xyXG4gICAgICAgICAgbmFtZTogJ2xvY2FsZSdcclxuICAgICAgfVxyXG4gIF07XHJcbiAgdmFyIGFscGhhX2Rhc2ggPSB7XHJcbiAgICAgIHZhbGlkYXRlOiB2YWxpZGF0ZSQxLFxyXG4gICAgICBwYXJhbXM6IHBhcmFtcyQxXHJcbiAgfTtcblxuICB2YXIgdmFsaWRhdGUkMiA9IGZ1bmN0aW9uICh2YWx1ZSwgX2EpIHtcclxuICAgICAgdmFyIF9iID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5sb2NhbGUsIGxvY2FsZSA9IF9iID09PSB2b2lkIDAgPyAnJyA6IF9iO1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgIHJldHVybiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWxpZGF0ZSQyKHZhbCwgeyBsb2NhbGU6IGxvY2FsZSB9KTsgfSk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gTWF0Y2ggYXQgbGVhc3Qgb25lIGxvY2FsZS5cclxuICAgICAgaWYgKCFsb2NhbGUpIHtcclxuICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhhbHBoYW51bWVyaWMpLnNvbWUoZnVuY3Rpb24gKGxvYykgeyByZXR1cm4gYWxwaGFudW1lcmljW2xvY10udGVzdCh2YWx1ZSk7IH0pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAoYWxwaGFudW1lcmljW2xvY2FsZV0gfHwgYWxwaGFudW1lcmljLmVuKS50ZXN0KHZhbHVlKTtcclxuICB9O1xyXG4gIHZhciBwYXJhbXMkMiA9IFtcclxuICAgICAge1xyXG4gICAgICAgICAgbmFtZTogJ2xvY2FsZSdcclxuICAgICAgfVxyXG4gIF07XHJcbiAgdmFyIGFscGhhX251bSA9IHtcclxuICAgICAgdmFsaWRhdGU6IHZhbGlkYXRlJDIsXHJcbiAgICAgIHBhcmFtczogcGFyYW1zJDJcclxuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSQzID0gZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xyXG4gICAgICB2YXIgX2IgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLmxvY2FsZSwgbG9jYWxlID0gX2IgPT09IHZvaWQgMCA/ICcnIDogX2I7XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHZhbGlkYXRlJDModmFsLCB7IGxvY2FsZTogbG9jYWxlIH0pOyB9KTtcclxuICAgICAgfVxyXG4gICAgICAvLyBNYXRjaCBhdCBsZWFzdCBvbmUgbG9jYWxlLlxyXG4gICAgICBpZiAoIWxvY2FsZSkge1xyXG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGFscGhhU3BhY2VzKS5zb21lKGZ1bmN0aW9uIChsb2MpIHsgcmV0dXJuIGFscGhhU3BhY2VzW2xvY10udGVzdCh2YWx1ZSk7IH0pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAoYWxwaGFTcGFjZXNbbG9jYWxlXSB8fCBhbHBoYVNwYWNlcy5lbikudGVzdCh2YWx1ZSk7XHJcbiAgfTtcclxuICB2YXIgcGFyYW1zJDMgPSBbXHJcbiAgICAgIHtcclxuICAgICAgICAgIG5hbWU6ICdsb2NhbGUnXHJcbiAgICAgIH1cclxuICBdO1xyXG4gIHZhciBhbHBoYV9zcGFjZXMgPSB7XHJcbiAgICAgIHZhbGlkYXRlOiB2YWxpZGF0ZSQzLFxyXG4gICAgICBwYXJhbXM6IHBhcmFtcyQzXHJcbiAgfTtcblxuICB2YXIgdmFsaWRhdGUkNCA9IGZ1bmN0aW9uICh2YWx1ZSwgX2EpIHtcclxuICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG1pbiA9IF9iLm1pbiwgbWF4ID0gX2IubWF4O1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgIHJldHVybiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7IHJldHVybiAhIXZhbGlkYXRlJDQodmFsLCB7IG1pbjogbWluLCBtYXg6IG1heCB9KTsgfSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIE51bWJlcihtaW4pIDw9IHZhbHVlICYmIE51bWJlcihtYXgpID49IHZhbHVlO1xyXG4gIH07XHJcbiAgdmFyIHBhcmFtcyQ0ID0gW1xyXG4gICAgICB7XHJcbiAgICAgICAgICBuYW1lOiAnbWluJ1xyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgICBuYW1lOiAnbWF4J1xyXG4gICAgICB9XHJcbiAgXTtcclxuICB2YXIgYmV0d2VlbiA9IHtcclxuICAgICAgdmFsaWRhdGU6IHZhbGlkYXRlJDQsXHJcbiAgICAgIHBhcmFtczogcGFyYW1zJDRcclxuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSQ1ID0gZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xyXG4gICAgICB2YXIgdGFyZ2V0ID0gX2EudGFyZ2V0O1xyXG4gICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKSA9PT0gU3RyaW5nKHRhcmdldCk7XHJcbiAgfTtcclxuICB2YXIgcGFyYW1zJDUgPSBbXHJcbiAgICAgIHtcclxuICAgICAgICAgIG5hbWU6ICd0YXJnZXQnLFxyXG4gICAgICAgICAgaXNUYXJnZXQ6IHRydWVcclxuICAgICAgfVxyXG4gIF07XHJcbiAgdmFyIGNvbmZpcm1lZCA9IHtcclxuICAgICAgdmFsaWRhdGU6IHZhbGlkYXRlJDUsXHJcbiAgICAgIHBhcmFtczogcGFyYW1zJDVcclxuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSQ2ID0gZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xyXG4gICAgICB2YXIgbGVuZ3RoID0gX2EubGVuZ3RoO1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgIHJldHVybiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWxpZGF0ZSQ2KHZhbCwgeyBsZW5ndGg6IGxlbmd0aCB9KTsgfSk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHN0clZhbCA9IFN0cmluZyh2YWx1ZSk7XHJcbiAgICAgIHJldHVybiAvXlswLTldKiQvLnRlc3Qoc3RyVmFsKSAmJiBzdHJWYWwubGVuZ3RoID09PSBsZW5ndGg7XHJcbiAgfTtcclxuICB2YXIgcGFyYW1zJDYgPSBbXHJcbiAgICAgIHtcclxuICAgICAgICAgIG5hbWU6ICdsZW5ndGgnLFxyXG4gICAgICAgICAgY2FzdDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICBdO1xyXG4gIHZhciBkaWdpdHMgPSB7XHJcbiAgICAgIHZhbGlkYXRlOiB2YWxpZGF0ZSQ2LFxyXG4gICAgICBwYXJhbXM6IHBhcmFtcyQ2XHJcbiAgfTtcblxuICB2YXIgdmFsaWRhdGVJbWFnZSA9IGZ1bmN0aW9uIChmaWxlLCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgIHZhciBVUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkw7XHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgdmFyIGltYWdlID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgICBpbWFnZS5vbmVycm9yID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZShmYWxzZSk7IH07XHJcbiAgICAgICAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlKGltYWdlLndpZHRoID09PSB3aWR0aCAmJiBpbWFnZS5oZWlnaHQgPT09IGhlaWdodCk7IH07XHJcbiAgICAgICAgICBpbWFnZS5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpO1xyXG4gICAgICB9KTtcclxuICB9O1xyXG4gIHZhciB2YWxpZGF0ZSQ3ID0gZnVuY3Rpb24gKGZpbGVzLCBfYSkge1xyXG4gICAgICB2YXIgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgICB2YXIgbGlzdCA9IFtdO1xyXG4gICAgICBmaWxlcyA9IEFycmF5LmlzQXJyYXkoZmlsZXMpID8gZmlsZXMgOiBbZmlsZXNdO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAvLyBpZiBmaWxlIGlzIG5vdCBhbiBpbWFnZSwgcmVqZWN0LlxyXG4gICAgICAgICAgaWYgKCEvXFwuKGpwZ3xzdmd8anBlZ3xwbmd8Ym1wfGdpZikkL2kudGVzdChmaWxlc1tpXS5uYW1lKSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbGlzdC5wdXNoKGZpbGVzW2ldKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwobGlzdC5tYXAoZnVuY3Rpb24gKGZpbGUpIHsgcmV0dXJuIHZhbGlkYXRlSW1hZ2UoZmlsZSwgd2lkdGgsIGhlaWdodCk7IH0pKS50aGVuKGZ1bmN0aW9uICh2YWx1ZXMpIHtcclxuICAgICAgICAgIHJldHVybiB2YWx1ZXMuZXZlcnkoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHY7IH0pO1xyXG4gICAgICB9KTtcclxuICB9O1xyXG4gIHZhciBwYXJhbXMkNyA9IFtcclxuICAgICAge1xyXG4gICAgICAgICAgbmFtZTogJ3dpZHRoJyxcclxuICAgICAgICAgIGNhc3Q6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgICBuYW1lOiAnaGVpZ2h0JyxcclxuICAgICAgICAgIGNhc3Q6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgXTtcclxuICB2YXIgZGltZW5zaW9ucyA9IHtcclxuICAgICAgdmFsaWRhdGU6IHZhbGlkYXRlJDcsXHJcbiAgICAgIHBhcmFtczogcGFyYW1zJDdcclxuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xyXG4gICAgICB2YXIgbXVsdGlwbGUgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLm11bHRpcGxlO1xyXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgICAgdmFyIHJlID0gL14oKFtePD4oKVxcW1xcXVxcXFwuLDs6XFxzQFwiXSsoXFwuW148PigpXFxbXFxdXFxcXC4sOzpcXHNAXCJdKykqKXwoXCIuK1wiKSlAKChcXFtbMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcLlswLTldezEsM31cXC5bMC05XXsxLDN9XFxdKXwoKFthLXpBLVpcXC0wLTldK1xcLikrW2EtekEtWl17Mix9KSkkLztcclxuICAgICAgaWYgKG11bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpXHJcbiAgICAgICAgICAgICAgLnNwbGl0KCcsJylcclxuICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChlbWFpbFN0cikgeyByZXR1cm4gZW1haWxTdHIudHJpbSgpOyB9KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgIHJldHVybiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7IHJldHVybiByZS50ZXN0KFN0cmluZyh2YWwpKTsgfSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlLnRlc3QoU3RyaW5nKHZhbHVlKSk7XHJcbiAgfTtcclxuICB2YXIgcGFyYW1zJDggPSBbXHJcbiAgICAgIHtcclxuICAgICAgICAgIG5hbWU6ICdtdWx0aXBsZScsXHJcbiAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG4gICAgICB9XHJcbiAgXTtcclxuICB2YXIgZW1haWwgPSB7XHJcbiAgICAgIHZhbGlkYXRlOiB2YWxpZGF0ZSQ4LFxyXG4gICAgICBwYXJhbXM6IHBhcmFtcyQ4XHJcbiAgfTtcblxuICB2YXIgaXNOYU4kMSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAvLyBOYU4gaXMgdGhlIG9uZSB2YWx1ZSB0aGF0IGRvZXMgbm90IGVxdWFsIGl0c2VsZi5cclxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbiAgICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XHJcbiAgfTtcclxuICAvKipcclxuICAgKiBDaGVja3MgaWYgdGhlIHZhbHVlcyBhcmUgZWl0aGVyIG51bGwgb3IgdW5kZWZpbmVkLlxyXG4gICAqL1xyXG4gIHZhciBpc051bGxPclVuZGVmaW5lZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcclxuICB9O1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgdGhlIGRlZmF1bHQgZmxhZ3Mgb2JqZWN0LlxyXG4gICAqL1xyXG4gIHZhciBjcmVhdGVGbGFncyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XHJcbiAgICAgIHVudG91Y2hlZDogdHJ1ZSxcclxuICAgICAgdG91Y2hlZDogZmFsc2UsXHJcbiAgICAgIGRpcnR5OiBmYWxzZSxcclxuICAgICAgcHJpc3RpbmU6IHRydWUsXHJcbiAgICAgIHZhbGlkOiBmYWxzZSxcclxuICAgICAgaW52YWxpZDogZmFsc2UsXHJcbiAgICAgIHZhbGlkYXRlZDogZmFsc2UsXHJcbiAgICAgIHBlbmRpbmc6IGZhbHNlLFxyXG4gICAgICByZXF1aXJlZDogZmFsc2UsXHJcbiAgICAgIGNoYW5nZWQ6IGZhbHNlXHJcbiAgfSk7IH07XHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QuXHJcbiAgICovXHJcbiAgdmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICByZXR1cm4gb2JqICE9PSBudWxsICYmIG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShvYmopO1xyXG4gIH07XHJcbiAgZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xyXG4gICAgICByZXR1cm4geDtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogU2hhbGxvdyBvYmplY3QgY29tcGFyaXNvbi5cclxuICAgKi9cclxuICB2YXIgaXNFcXVhbCA9IGZ1bmN0aW9uIChsaHMsIHJocykge1xyXG4gICAgICBpZiAobGhzIGluc3RhbmNlb2YgUmVnRXhwICYmIHJocyBpbnN0YW5jZW9mIFJlZ0V4cCkge1xyXG4gICAgICAgICAgcmV0dXJuIGlzRXF1YWwobGhzLnNvdXJjZSwgcmhzLnNvdXJjZSkgJiYgaXNFcXVhbChsaHMuZmxhZ3MsIHJocy5mbGFncyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGhzKSAmJiBBcnJheS5pc0FycmF5KHJocykpIHtcclxuICAgICAgICAgIGlmIChsaHMubGVuZ3RoICE9PSByaHMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGhzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsKGxoc1tpXSwgcmhzW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgLy8gaWYgYm90aCBhcmUgb2JqZWN0cywgY29tcGFyZSBlYWNoIGtleSByZWN1cnNpdmVseS5cclxuICAgICAgaWYgKGlzT2JqZWN0KGxocykgJiYgaXNPYmplY3QocmhzKSkge1xyXG4gICAgICAgICAgcmV0dXJuIChPYmplY3Qua2V5cyhsaHMpLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gaXNFcXVhbChsaHNba2V5XSwgcmhzW2tleV0pO1xyXG4gICAgICAgICAgfSkgJiZcclxuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhyaHMpLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzRXF1YWwobGhzW2tleV0sIHJoc1trZXldKTtcclxuICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGlzTmFOJDEobGhzKSAmJiBpc05hTiQxKHJocykpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBsaHMgPT09IHJocztcclxuICB9O1xyXG4gIHZhciBpbmNsdWRlcyA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBpdGVtKSB7XHJcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmluZGV4T2YoaXRlbSkgIT09IC0xO1xyXG4gIH07XHJcbiAgLyoqXHJcbiAgICogUGFyc2VzIGEgcnVsZSBzdHJpbmcgZXhwcmVzc2lvbi5cclxuICAgKi9cclxuICB2YXIgcGFyc2VSdWxlID0gZnVuY3Rpb24gKHJ1bGUpIHtcclxuICAgICAgdmFyIHBhcmFtcyA9IFtdO1xyXG4gICAgICB2YXIgbmFtZSA9IHJ1bGUuc3BsaXQoJzonKVswXTtcclxuICAgICAgaWYgKGluY2x1ZGVzKHJ1bGUsICc6JykpIHtcclxuICAgICAgICAgIHBhcmFtcyA9IHJ1bGVcclxuICAgICAgICAgICAgICAuc3BsaXQoJzonKVxyXG4gICAgICAgICAgICAgIC5zbGljZSgxKVxyXG4gICAgICAgICAgICAgIC5qb2luKCc6JylcclxuICAgICAgICAgICAgICAuc3BsaXQoJywnKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4geyBuYW1lOiBuYW1lLCBwYXJhbXM6IHBhcmFtcyB9O1xyXG4gIH07XHJcbiAgLyoqXHJcbiAgICogRGVib3VuY2VzIGEgZnVuY3Rpb24uXHJcbiAgICovXHJcbiAgdmFyIGRlYm91bmNlID0gZnVuY3Rpb24gKGZuLCB3YWl0LCB0b2tlbikge1xyXG4gICAgICBpZiAod2FpdCA9PT0gdm9pZCAwKSB7IHdhaXQgPSAwOyB9XHJcbiAgICAgIGlmICh0b2tlbiA9PT0gdm9pZCAwKSB7IHRva2VuID0geyBjYW5jZWxsZWQ6IGZhbHNlIH07IH1cclxuICAgICAgaWYgKHdhaXQgPT09IDApIHtcclxuICAgICAgICAgIHJldHVybiBmbjtcclxuICAgICAgfVxyXG4gICAgICB2YXIgdGltZW91dDtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICB0aW1lb3V0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBmbiBjYWxsIHdhcyBjYW5jZWxsZWQuXHJcbiAgICAgICAgICAgICAgaWYgKCF0b2tlbi5jYW5jZWxsZWQpXHJcbiAgICAgICAgICAgICAgICAgIGZuLmFwcGx5KHZvaWQgMCwgYXJncyk7XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgLy8gYmVjYXVzZSB3ZSBtaWdodCB3YW50IHRvIHVzZSBOb2RlLmpzIHNldFRpbW91dCBmb3IgU1NSLlxyXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xyXG4gICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xyXG4gICAgICB9O1xyXG4gIH07XHJcbiAgLyoqXHJcbiAgICogRW1pdHMgYSB3YXJuaW5nIHRvIHRoZSBjb25zb2xlLlxyXG4gICAqL1xyXG4gIHZhciB3YXJuID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgICAgY29uc29sZS53YXJuKFwiW3ZlZS12YWxpZGF0ZV0gXCIgKyBtZXNzYWdlKTtcclxuICB9O1xyXG4gIC8qKlxyXG4gICAqIE5vcm1hbGl6ZXMgdGhlIGdpdmVuIHJ1bGVzIGV4cHJlc3Npb24uXHJcbiAgICovXHJcbiAgdmFyIG5vcm1hbGl6ZVJ1bGVzID0gZnVuY3Rpb24gKHJ1bGVzKSB7XHJcbiAgICAgIC8vIGlmIGZhbHN5IHZhbHVlIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXHJcbiAgICAgIHZhciBhY2MgPSB7fTtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFjYywgJ18kJGlzTm9ybWFsaXplZCcsIHtcclxuICAgICAgICAgIHZhbHVlOiB0cnVlLFxyXG4gICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAoIXJ1bGVzKSB7XHJcbiAgICAgICAgICByZXR1cm4gYWNjO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIE9iamVjdCBpcyBhbHJlYWR5IG5vcm1hbGl6ZWQsIHNraXAuXHJcbiAgICAgIGlmIChpc09iamVjdChydWxlcykgJiYgcnVsZXMuXyQkaXNOb3JtYWxpemVkKSB7XHJcbiAgICAgICAgICByZXR1cm4gcnVsZXM7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGlzT2JqZWN0KHJ1bGVzKSkge1xyXG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHJ1bGVzKS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIpIHtcclxuICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gW107XHJcbiAgICAgICAgICAgICAgaWYgKHJ1bGVzW2N1cnJdID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IFtdO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJ1bGVzW2N1cnJdKSkge1xyXG4gICAgICAgICAgICAgICAgICBwYXJhbXMgPSBydWxlc1tjdXJyXTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QocnVsZXNbY3Vycl0pKSB7XHJcbiAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHJ1bGVzW2N1cnJdO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgcGFyYW1zID0gW3J1bGVzW2N1cnJdXTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKHJ1bGVzW2N1cnJdICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICBwcmV2W2N1cnJdID0gcGFyYW1zO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICByZXR1cm4gcHJldjtcclxuICAgICAgICAgIH0sIGFjYyk7XHJcbiAgICAgIH1cclxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgIGlmICh0eXBlb2YgcnVsZXMgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICB3YXJuKCdydWxlcyBtdXN0IGJlIGVpdGhlciBhIHN0cmluZyBvciBhbiBvYmplY3QuJyk7XHJcbiAgICAgICAgICByZXR1cm4gYWNjO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBydWxlcy5zcGxpdCgnfCcpLnJlZHVjZShmdW5jdGlvbiAocHJldiwgcnVsZSkge1xyXG4gICAgICAgICAgdmFyIHBhcnNlZFJ1bGUgPSBwYXJzZVJ1bGUocnVsZSk7XHJcbiAgICAgICAgICBwcmV2W3BhcnNlZFJ1bGUubmFtZV0gPSBwYXJzZWRSdWxlLnBhcmFtcztcclxuICAgICAgICAgIHJldHVybiBwcmV2O1xyXG4gICAgICB9LCBhY2MpO1xyXG4gIH07XHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIGEgZnVuY3Rpb24gaXMgY2FsbGFibGUuXHJcbiAgICovXHJcbiAgdmFyIGlzQ2FsbGFibGUgPSBmdW5jdGlvbiAoZnVuYykgeyByZXR1cm4gdHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbic7IH07XHJcbiAgZnVuY3Rpb24gY29tcHV0ZUNsYXNzT2JqKG5hbWVzLCBmbGFncykge1xyXG4gICAgICB2YXIgYWNjID0ge307XHJcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZmxhZ3MpO1xyXG4gICAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XHJcbiAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgIHZhciBmbGFnID0ga2V5c1tpXTtcclxuICAgICAgICAgIHZhciBjbGFzc05hbWUgPSAobmFtZXMgJiYgbmFtZXNbZmxhZ10pIHx8IGZsYWc7XHJcbiAgICAgICAgICB2YXIgdmFsdWUgPSBmbGFnc1tmbGFnXTtcclxuICAgICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKChmbGFnID09PSAndmFsaWQnIHx8IGZsYWcgPT09ICdpbnZhbGlkJykgJiYgIWZsYWdzLnZhbGlkYXRlZCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAodHlwZW9mIGNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICBhY2NbY2xhc3NOYW1lXSA9IHZhbHVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjbGFzc05hbWUpKSB7XHJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lLmZvckVhY2goZnVuY3Rpb24gKGNscykge1xyXG4gICAgICAgICAgICAgICAgICBhY2NbY2xzXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBfbG9vcF8xKGkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBhY2M7XHJcbiAgfVxyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgZnVuY3Rpb24gX2NvcHlBcnJheShhcnJheUxpa2UpIHtcclxuICAgICAgdmFyIGFycmF5ID0gW107XHJcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheUxpa2UubGVuZ3RoO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBhcnJheS5wdXNoKGFycmF5TGlrZVtpXSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGFycmF5O1xyXG4gIH1cclxuICAvKipcclxuICAgKiBDb252ZXJ0cyBhbiBhcnJheS1saWtlIG9iamVjdCB0byBhcnJheSwgcHJvdmlkZXMgYSBzaW1wbGUgcG9seWZpbGwgZm9yIEFycmF5LmZyb21cclxuICAgKi9cclxuICBmdW5jdGlvbiB0b0FycmF5KGFycmF5TGlrZSkge1xyXG4gICAgICBpZiAoaXNDYWxsYWJsZShBcnJheS5mcm9tKSkge1xyXG4gICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oYXJyYXlMaWtlKTtcclxuICAgICAgfVxyXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICByZXR1cm4gX2NvcHlBcnJheShhcnJheUxpa2UpO1xyXG4gIH1cclxuICBmdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXlMaWtlLCBwcmVkaWNhdGUpIHtcclxuICAgICAgdmFyIGFycmF5ID0gQXJyYXkuaXNBcnJheShhcnJheUxpa2UpID8gYXJyYXlMaWtlIDogdG9BcnJheShhcnJheUxpa2UpO1xyXG4gICAgICBpZiAoaXNDYWxsYWJsZShhcnJheS5maW5kSW5kZXgpKSB7XHJcbiAgICAgICAgICByZXR1cm4gYXJyYXkuZmluZEluZGV4KHByZWRpY2F0ZSk7XHJcbiAgICAgIH1cclxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpXSwgaSkpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICByZXR1cm4gLTE7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIGZpbmRzIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgc2F0aXNmaWVzIHRoZSBwcmVkaWNhdGUgY2FsbGJhY2ssIHBvbHlmaWxscyBhcnJheS5maW5kXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gZmluZChhcnJheUxpa2UsIHByZWRpY2F0ZSkge1xyXG4gICAgICB2YXIgYXJyYXkgPSBBcnJheS5pc0FycmF5KGFycmF5TGlrZSkgPyBhcnJheUxpa2UgOiB0b0FycmF5KGFycmF5TGlrZSk7XHJcbiAgICAgIHZhciBpZHggPSBmaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSk7XHJcbiAgICAgIHJldHVybiBpZHggPT09IC0xID8gdW5kZWZpbmVkIDogYXJyYXlbaWR4XTtcclxuICB9XHJcbiAgZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBzb3VyY2UpIHtcclxuICAgICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgIGlmIChpc09iamVjdChzb3VyY2Vba2V5XSkpIHtcclxuICAgICAgICAgICAgICBpZiAoIXRhcmdldFtrZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0ge307XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIG1lcmdlKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHZhbHVlcyhvYmopIHtcclxuICAgICAgaWYgKGlzQ2FsbGFibGUoT2JqZWN0LnZhbHVlcykpIHtcclxuICAgICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKG9iaik7XHJcbiAgICAgIH1cclxuICAgICAgLy8gZmFsbGJhY2sgdG8ga2V5cygpXHJcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbiAoaykgeyByZXR1cm4gb2JqW2tdOyB9KTtcclxuICB9XHJcbiAgdmFyIGlzRW1wdHlBcnJheSA9IGZ1bmN0aW9uIChhcnIpIHtcclxuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJyKSAmJiBhcnIubGVuZ3RoID09PSAwO1xyXG4gIH07XHJcbiAgdmFyIGludGVycG9sYXRlID0gZnVuY3Rpb24gKHRlbXBsYXRlLCB2YWx1ZXMpIHtcclxuICAgICAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoL1xceyhbXn1dKylcXH0vZywgZnVuY3Rpb24gKF8sIHApIHtcclxuICAgICAgICAgIHJldHVybiBwIGluIHZhbHVlcyA/IHZhbHVlc1twXSA6IFwie1wiICsgcCArIFwifVwiO1xyXG4gICAgICB9KTtcclxuICB9O1xyXG4gIC8vIENoZWNrcyBpZiBhIGdpdmVuIHZhbHVlIGlzIG5vdCBhbiBlbXB0eSBzdHJpbmcgb3IgbnVsbCBvciB1bmRlZmluZWQuXHJcbiAgdmFyIGlzU3BlY2lmaWVkID0gZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICBpZiAodmFsID09PSAnJykge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAhaXNOdWxsT3JVbmRlZmluZWQodmFsKTtcclxuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSQ5ID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHZhbGlkYXRlJDkodmFsLCBvcHRpb25zKTsgfSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRvQXJyYXkob3B0aW9ucykuc29tZShmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbiAgICAgICAgICByZXR1cm4gaXRlbSA9PSB2YWx1ZTtcclxuICAgICAgfSk7XHJcbiAgfTtcclxuICB2YXIgb25lT2YgPSB7XHJcbiAgICAgIHZhbGlkYXRlOiB2YWxpZGF0ZSQ5XHJcbiAgfTtcblxuICB2YXIgdmFsaWRhdGUkYSA9IGZ1bmN0aW9uICh2YWx1ZSwgYXJncykge1xyXG4gICAgICByZXR1cm4gIXZhbGlkYXRlJDkodmFsdWUsIGFyZ3MpO1xyXG4gIH07XHJcbiAgdmFyIGV4Y2x1ZGVkID0ge1xyXG4gICAgICB2YWxpZGF0ZTogdmFsaWRhdGUkYVxyXG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlJGIgPSBmdW5jdGlvbiAoZmlsZXMsIGV4dGVuc2lvbnMpIHtcclxuICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cChcIi4oXCIgKyBleHRlbnNpb25zLmpvaW4oJ3wnKSArIFwiKSRcIiwgJ2knKTtcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmlsZXMpKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmlsZXMuZXZlcnkoZnVuY3Rpb24gKGZpbGUpIHsgcmV0dXJuIHJlZ2V4LnRlc3QoZmlsZS5uYW1lKTsgfSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlZ2V4LnRlc3QoZmlsZXMubmFtZSk7XHJcbiAgfTtcclxuICB2YXIgZXh0ID0ge1xyXG4gICAgICB2YWxpZGF0ZTogdmFsaWRhdGUkYlxyXG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlJGMgPSBmdW5jdGlvbiAoZmlsZXMpIHtcclxuICAgICAgdmFyIHJlZ2V4ID0gL1xcLihqcGd8c3ZnfGpwZWd8cG5nfGJtcHxnaWYpJC9pO1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShmaWxlcykpIHtcclxuICAgICAgICAgIHJldHVybiBmaWxlcy5ldmVyeShmdW5jdGlvbiAoZmlsZSkgeyByZXR1cm4gcmVnZXgudGVzdChmaWxlLm5hbWUpOyB9KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVnZXgudGVzdChmaWxlcy5uYW1lKTtcclxuICB9O1xyXG4gIHZhciBpbWFnZSA9IHtcclxuICAgICAgdmFsaWRhdGU6IHZhbGlkYXRlJGNcclxuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSRkID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIC9eLT9bMC05XSskLy50ZXN0KFN0cmluZyh2YWwpKTsgfSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIC9eLT9bMC05XSskLy50ZXN0KFN0cmluZyh2YWx1ZSkpO1xyXG4gIH07XHJcbiAgdmFyIGludGVnZXIgPSB7XHJcbiAgICAgIHZhbGlkYXRlOiB2YWxpZGF0ZSRkXHJcbiAgfTtcblxuICB2YXIgdmFsaWRhdGUkZSA9IGZ1bmN0aW9uICh2YWx1ZSwgX2EpIHtcclxuICAgICAgdmFyIG90aGVyID0gX2Eub3RoZXI7XHJcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gb3RoZXI7XHJcbiAgfTtcclxuICB2YXIgcGFyYW1zJDkgPSBbXHJcbiAgICAgIHtcclxuICAgICAgICAgIG5hbWU6ICdvdGhlcidcclxuICAgICAgfVxyXG4gIF07XHJcbiAgdmFyIGlzID0ge1xyXG4gICAgICB2YWxpZGF0ZTogdmFsaWRhdGUkZSxcclxuICAgICAgcGFyYW1zOiBwYXJhbXMkOVxyXG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlJGYgPSBmdW5jdGlvbiAodmFsdWUsIF9hKSB7XHJcbiAgICAgIHZhciBvdGhlciA9IF9hLm90aGVyO1xyXG4gICAgICByZXR1cm4gdmFsdWUgIT09IG90aGVyO1xyXG4gIH07XHJcbiAgdmFyIHBhcmFtcyRhID0gW1xyXG4gICAgICB7XHJcbiAgICAgICAgICBuYW1lOiAnb3RoZXInXHJcbiAgICAgIH1cclxuICBdO1xyXG4gIHZhciBpc19ub3QgPSB7XHJcbiAgICAgIHZhbGlkYXRlOiB2YWxpZGF0ZSRmLFxyXG4gICAgICBwYXJhbXM6IHBhcmFtcyRhXHJcbiAgfTtcblxuICB2YXIgdmFsaWRhdGUkZyA9IGZ1bmN0aW9uICh2YWx1ZSwgX2EpIHtcclxuICAgICAgdmFyIGxlbmd0aCA9IF9hLmxlbmd0aDtcclxuICAgICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSkge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCF2YWx1ZS5sZW5ndGgpIHtcclxuICAgICAgICAgIHZhbHVlID0gdG9BcnJheSh2YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA9PT0gbGVuZ3RoO1xyXG4gIH07XHJcbiAgdmFyIHBhcmFtcyRiID0gW1xyXG4gICAgICB7XHJcbiAgICAgICAgICBuYW1lOiAnbGVuZ3RoJyxcclxuICAgICAgICAgIGNhc3Q6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gTnVtYmVyKHZhbHVlKTsgfVxyXG4gICAgICB9XHJcbiAgXTtcclxuICB2YXIgbGVuZ3RoID0ge1xyXG4gICAgICB2YWxpZGF0ZTogdmFsaWRhdGUkZyxcclxuICAgICAgcGFyYW1zOiBwYXJhbXMkYlxyXG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlJGggPSBmdW5jdGlvbiAodmFsdWUsIF9hKSB7XHJcbiAgICAgIHZhciBsZW5ndGggPSBfYS5sZW5ndGg7XHJcbiAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkpIHtcclxuICAgICAgICAgIHJldHVybiBsZW5ndGggPj0gMDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgIHJldHVybiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWxpZGF0ZSRoKHZhbCwgeyBsZW5ndGg6IGxlbmd0aCB9KTsgfSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSkubGVuZ3RoIDw9IGxlbmd0aDtcclxuICB9O1xyXG4gIHZhciBwYXJhbXMkYyA9IFtcclxuICAgICAge1xyXG4gICAgICAgICAgbmFtZTogJ2xlbmd0aCcsXHJcbiAgICAgICAgICBjYXN0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gIF07XHJcbiAgdmFyIG1heCA9IHtcclxuICAgICAgdmFsaWRhdGU6IHZhbGlkYXRlJGgsXHJcbiAgICAgIHBhcmFtczogcGFyYW1zJGNcclxuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSRpID0gZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xyXG4gICAgICB2YXIgbWF4ID0gX2EubWF4O1xyXG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpIHx8IHZhbHVlID09PSAnJykge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA+IDAgJiYgdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsaWRhdGUkaSh2YWwsIHsgbWF4OiBtYXggfSk7IH0pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpIDw9IG1heDtcclxuICB9O1xyXG4gIHZhciBwYXJhbXMkZCA9IFtcclxuICAgICAge1xyXG4gICAgICAgICAgbmFtZTogJ21heCcsXHJcbiAgICAgICAgICBjYXN0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gIF07XHJcbiAgdmFyIG1heF92YWx1ZSA9IHtcclxuICAgICAgdmFsaWRhdGU6IHZhbGlkYXRlJGksXHJcbiAgICAgIHBhcmFtczogcGFyYW1zJGRcclxuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSRqID0gZnVuY3Rpb24gKGZpbGVzLCBtaW1lcykge1xyXG4gICAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKG1pbWVzLmpvaW4oJ3wnKS5yZXBsYWNlKCcqJywgJy4rJykgKyBcIiRcIiwgJ2knKTtcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmlsZXMpKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmlsZXMuZXZlcnkoZnVuY3Rpb24gKGZpbGUpIHsgcmV0dXJuIHJlZ2V4LnRlc3QoZmlsZS50eXBlKTsgfSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlZ2V4LnRlc3QoZmlsZXMudHlwZSk7XHJcbiAgfTtcclxuICB2YXIgbWltZXMgPSB7XHJcbiAgICAgIHZhbGlkYXRlOiB2YWxpZGF0ZSRqXHJcbiAgfTtcblxuICB2YXIgdmFsaWRhdGUkayA9IGZ1bmN0aW9uICh2YWx1ZSwgX2EpIHtcclxuICAgICAgdmFyIGxlbmd0aCA9IF9hLmxlbmd0aDtcclxuICAgICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSkge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHZhbGlkYXRlJGsodmFsLCB7IGxlbmd0aDogbGVuZ3RoIH0pOyB9KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKS5sZW5ndGggPj0gbGVuZ3RoO1xyXG4gIH07XHJcbiAgdmFyIHBhcmFtcyRlID0gW1xyXG4gICAgICB7XHJcbiAgICAgICAgICBuYW1lOiAnbGVuZ3RoJyxcclxuICAgICAgICAgIGNhc3Q6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgXTtcclxuICB2YXIgbWluID0ge1xyXG4gICAgICB2YWxpZGF0ZTogdmFsaWRhdGUkayxcclxuICAgICAgcGFyYW1zOiBwYXJhbXMkZVxyXG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlJGwgPSBmdW5jdGlvbiAodmFsdWUsIF9hKSB7XHJcbiAgICAgIHZhciBtaW4gPSBfYS5taW47XHJcbiAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkgfHwgdmFsdWUgPT09ICcnKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID4gMCAmJiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWxpZGF0ZSRsKHZhbCwgeyBtaW46IG1pbiB9KTsgfSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSkgPj0gbWluO1xyXG4gIH07XHJcbiAgdmFyIHBhcmFtcyRmID0gW1xyXG4gICAgICB7XHJcbiAgICAgICAgICBuYW1lOiAnbWluJyxcclxuICAgICAgICAgIGNhc3Q6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgXTtcclxuICB2YXIgbWluX3ZhbHVlID0ge1xyXG4gICAgICB2YWxpZGF0ZTogdmFsaWRhdGUkbCxcclxuICAgICAgcGFyYW1zOiBwYXJhbXMkZlxyXG4gIH07XG5cbiAgdmFyIGFyID0gL15b2aDZodmi2aPZpNml2abZp9mo2aldKyQvO1xyXG4gIHZhciBlbiQxID0gL15bMC05XSskLztcclxuICB2YXIgdmFsaWRhdGUkbSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICB2YXIgdGVzdFZhbHVlID0gZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICAgICAgdmFyIHN0clZhbHVlID0gU3RyaW5nKHZhbCk7XHJcbiAgICAgICAgICByZXR1cm4gZW4kMS50ZXN0KHN0clZhbHVlKSB8fCBhci50ZXN0KHN0clZhbHVlKTtcclxuICAgICAgfTtcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICByZXR1cm4gdmFsdWUuZXZlcnkodGVzdFZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGVzdFZhbHVlKHZhbHVlKTtcclxuICB9O1xyXG4gIHZhciBudW1lcmljID0ge1xyXG4gICAgICB2YWxpZGF0ZTogdmFsaWRhdGUkbVxyXG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlJG4gPSBmdW5jdGlvbiAodmFsdWUsIF9hKSB7XHJcbiAgICAgIHZhciByZWdleCA9IF9hLnJlZ2V4O1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgIHJldHVybiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWxpZGF0ZSRuKHZhbCwgeyByZWdleDogcmVnZXggfSk7IH0pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZWdleC50ZXN0KFN0cmluZyh2YWx1ZSkpO1xyXG4gIH07XHJcbiAgdmFyIHBhcmFtcyRnID0gW1xyXG4gICAgICB7XHJcbiAgICAgICAgICBuYW1lOiAncmVnZXgnLFxyXG4gICAgICAgICAgY2FzdDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodmFsdWUpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICBdO1xyXG4gIHZhciByZWdleCA9IHtcclxuICAgICAgdmFsaWRhdGU6IHZhbGlkYXRlJG4sXHJcbiAgICAgIHBhcmFtczogcGFyYW1zJGdcclxuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSRvID0gZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xyXG4gICAgICB2YXIgYWxsb3dGYWxzZSA9IChfYSA9PT0gdm9pZCAwID8geyBhbGxvd0ZhbHNlOiB0cnVlIH0gOiBfYSkuYWxsb3dGYWxzZTtcclxuICAgICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgICAgIHZhbGlkOiBmYWxzZSxcclxuICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXHJcbiAgICAgIH07XHJcbiAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkgfHwgaXNFbXB0eUFycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG4gICAgICAvLyBpbmNhc2UgYSBmaWVsZCBjb25zaWRlcnMgYGZhbHNlYCBhcyBhbiBlbXB0eSB2YWx1ZSBsaWtlIGNoZWNrYm94ZXMuXHJcbiAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UgJiYgIWFsbG93RmFsc2UpIHtcclxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH1cclxuICAgICAgcmVzdWx0LnZhbGlkID0gISFTdHJpbmcodmFsdWUpLnRyaW0oKS5sZW5ndGg7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfTtcclxuICB2YXIgY29tcHV0ZXNSZXF1aXJlZCA9IHRydWU7XHJcbiAgdmFyIHBhcmFtcyRoID0gW1xyXG4gICAgICB7XHJcbiAgICAgICAgICBuYW1lOiAnYWxsb3dGYWxzZScsXHJcbiAgICAgICAgICBkZWZhdWx0OiB0cnVlXHJcbiAgICAgIH1cclxuICBdO1xyXG4gIHZhciByZXF1aXJlZCA9IHtcclxuICAgICAgdmFsaWRhdGU6IHZhbGlkYXRlJG8sXHJcbiAgICAgIHBhcmFtczogcGFyYW1zJGgsXHJcbiAgICAgIGNvbXB1dGVzUmVxdWlyZWQ6IGNvbXB1dGVzUmVxdWlyZWRcclxuICB9O1xuXG4gIHZhciB0ZXN0RW1wdHkgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgcmV0dXJuIGlzRW1wdHlBcnJheSh2YWx1ZSkgfHwgaW5jbHVkZXMoW2ZhbHNlLCBudWxsLCB1bmRlZmluZWRdLCB2YWx1ZSkgfHwgIVN0cmluZyh2YWx1ZSkudHJpbSgpLmxlbmd0aDtcclxuICB9O1xyXG4gIHZhciB2YWxpZGF0ZSRwID0gZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xyXG4gICAgICB2YXIgdGFyZ2V0ID0gX2EudGFyZ2V0LCB2YWx1ZXMgPSBfYS52YWx1ZXM7XHJcbiAgICAgIHZhciByZXF1aXJlZDtcclxuICAgICAgaWYgKHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAvLyBlc2xpbnQtaWdub3JlLW5leHQtbGluZVxyXG4gICAgICAgICAgcmVxdWlyZWQgPSB2YWx1ZXMuc29tZShmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWwgPT0gU3RyaW5nKHRhcmdldCkudHJpbSgpOyB9KTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAgIHJlcXVpcmVkID0gIXRlc3RFbXB0eSh0YXJnZXQpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghcmVxdWlyZWQpIHtcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgdmFsaWQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgcmVxdWlyZWQ6IHJlcXVpcmVkXHJcbiAgICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICB2YWxpZDogIXRlc3RFbXB0eSh2YWx1ZSksXHJcbiAgICAgICAgICByZXF1aXJlZDogcmVxdWlyZWRcclxuICAgICAgfTtcclxuICB9O1xyXG4gIHZhciBwYXJhbXMkaSA9IFtcclxuICAgICAge1xyXG4gICAgICAgICAgbmFtZTogJ3RhcmdldCcsXHJcbiAgICAgICAgICBpc1RhcmdldDogdHJ1ZVxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgICBuYW1lOiAndmFsdWVzJ1xyXG4gICAgICB9XHJcbiAgXTtcclxuICB2YXIgY29tcHV0ZXNSZXF1aXJlZCQxID0gdHJ1ZTtcclxuICB2YXIgcmVxdWlyZWRfaWYgPSB7XHJcbiAgICAgIHZhbGlkYXRlOiB2YWxpZGF0ZSRwLFxyXG4gICAgICBwYXJhbXM6IHBhcmFtcyRpLFxyXG4gICAgICBjb21wdXRlc1JlcXVpcmVkOiBjb21wdXRlc1JlcXVpcmVkJDFcclxuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSRxID0gZnVuY3Rpb24gKGZpbGVzLCBfYSkge1xyXG4gICAgICB2YXIgc2l6ZSA9IF9hLnNpemU7XHJcbiAgICAgIGlmIChpc05hTihzaXplKSkge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBuU2l6ZSA9IHNpemUgKiAxMDI0O1xyXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZmlsZXMpKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmlsZXMuc2l6ZSA8PSBuU2l6ZTtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAoZmlsZXNbaV0uc2l6ZSA+IG5TaXplKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gIH07XHJcbiAgdmFyIHBhcmFtcyRqID0gW1xyXG4gICAgICB7XHJcbiAgICAgICAgICBuYW1lOiAnc2l6ZScsXHJcbiAgICAgICAgICBjYXN0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gIF07XHJcbiAgdmFyIHNpemUgPSB7XHJcbiAgICAgIHZhbGlkYXRlOiB2YWxpZGF0ZSRxLFxyXG4gICAgICBwYXJhbXM6IHBhcmFtcyRqXHJcbiAgfTtcblxuXG5cbiAgdmFyIFJ1bGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIGFscGhhX2Rhc2g6IGFscGhhX2Rhc2gsXG4gICAgYWxwaGFfbnVtOiBhbHBoYV9udW0sXG4gICAgYWxwaGFfc3BhY2VzOiBhbHBoYV9zcGFjZXMsXG4gICAgYWxwaGE6IGFscGhhJDEsXG4gICAgYmV0d2VlbjogYmV0d2VlbixcbiAgICBjb25maXJtZWQ6IGNvbmZpcm1lZCxcbiAgICBkaWdpdHM6IGRpZ2l0cyxcbiAgICBkaW1lbnNpb25zOiBkaW1lbnNpb25zLFxuICAgIGVtYWlsOiBlbWFpbCxcbiAgICBleHQ6IGV4dCxcbiAgICBpbWFnZTogaW1hZ2UsXG4gICAgb25lT2Y6IG9uZU9mLFxuICAgIGludGVnZXI6IGludGVnZXIsXG4gICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgaXNfbm90OiBpc19ub3QsXG4gICAgaXM6IGlzLFxuICAgIG1heDogbWF4LFxuICAgIG1heF92YWx1ZTogbWF4X3ZhbHVlLFxuICAgIG1pbWVzOiBtaW1lcyxcbiAgICBtaW46IG1pbixcbiAgICBtaW5fdmFsdWU6IG1pbl92YWx1ZSxcbiAgICBleGNsdWRlZDogZXhjbHVkZWQsXG4gICAgbnVtZXJpYzogbnVtZXJpYyxcbiAgICByZWdleDogcmVnZXgsXG4gICAgcmVxdWlyZWQ6IHJlcXVpcmVkLFxuICAgIHJlcXVpcmVkX2lmOiByZXF1aXJlZF9pZixcbiAgICBzaXplOiBzaXplXG4gIH0pO1xuXG4gIC8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG4gIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbiAgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcbiAgVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4gIEtJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuICBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG4gIE1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG4gIFNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG4gIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuICB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiB0O1xyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgICB9KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcclxuICAgICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxyXG4gICAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgICByZXR1cm4gcjtcclxuICB9XG5cbiAgdmFyIFJVTEVTID0ge307XHJcbiAgZnVuY3Rpb24gbm9ybWFsaXplU2NoZW1hKHNjaGVtYSkge1xyXG4gICAgICBpZiAoc2NoZW1hLnBhcmFtcyAmJiBzY2hlbWEucGFyYW1zLmxlbmd0aCkge1xyXG4gICAgICAgICAgc2NoZW1hLnBhcmFtcyA9IHNjaGVtYS5wYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkge1xyXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW0gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7IG5hbWU6IHBhcmFtIH07XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHJldHVybiBwYXJhbTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzY2hlbWE7XHJcbiAgfVxyXG4gIHZhciBSdWxlQ29udGFpbmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICBmdW5jdGlvbiBSdWxlQ29udGFpbmVyKCkge1xyXG4gICAgICB9XHJcbiAgICAgIFJ1bGVDb250YWluZXIuZXh0ZW5kID0gZnVuY3Rpb24gKG5hbWUsIHNjaGVtYSkge1xyXG4gICAgICAgICAgLy8gaWYgcnVsZSBhbHJlYWR5IGV4aXN0cywgb3ZlcndyaXRlIGl0LlxyXG4gICAgICAgICAgdmFyIHJ1bGUgPSBub3JtYWxpemVTY2hlbWEoc2NoZW1hKTtcclxuICAgICAgICAgIGlmIChSVUxFU1tuYW1lXSkge1xyXG4gICAgICAgICAgICAgIFJVTEVTW25hbWVdID0gbWVyZ2UoUlVMRVNbbmFtZV0sIHNjaGVtYSk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgUlVMRVNbbmFtZV0gPSBfX2Fzc2lnbih7IGxhenk6IGZhbHNlLCBjb21wdXRlc1JlcXVpcmVkOiBmYWxzZSB9LCBydWxlKTtcclxuICAgICAgfTtcclxuICAgICAgUnVsZUNvbnRhaW5lci5pdGVyYXRlID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKFJVTEVTKTtcclxuICAgICAgICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcclxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICBmbihrZXlzW2ldLCBSVUxFU1trZXlzW2ldXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICAgIFJ1bGVDb250YWluZXIuaXNMYXp5ID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgIHJldHVybiAhIShSVUxFU1tuYW1lXSAmJiBSVUxFU1tuYW1lXS5sYXp5KTtcclxuICAgICAgfTtcclxuICAgICAgUnVsZUNvbnRhaW5lci5pc1JlcXVpcmVSdWxlID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgIHJldHVybiAhIShSVUxFU1tuYW1lXSAmJiBSVUxFU1tuYW1lXS5jb21wdXRlc1JlcXVpcmVkKTtcclxuICAgICAgfTtcclxuICAgICAgUnVsZUNvbnRhaW5lci5pc1RhcmdldFJ1bGUgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgdmFyIGRlZmluaXRpb24gPSBSdWxlQ29udGFpbmVyLmdldFJ1bGVEZWZpbml0aW9uKG5hbWUpO1xyXG4gICAgICAgICAgaWYgKCFkZWZpbml0aW9uIHx8ICFkZWZpbml0aW9uLnBhcmFtcykge1xyXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBkZWZpbml0aW9uLnBhcmFtcy5zb21lKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gISFwYXJhbS5pc1RhcmdldDsgfSk7XHJcbiAgICAgIH07XHJcbiAgICAgIFJ1bGVDb250YWluZXIuZ2V0VGFyZ2V0UGFyYW1OYW1lcyA9IGZ1bmN0aW9uIChydWxlLCBwYXJhbXMpIHtcclxuICAgICAgICAgIHZhciBkZWZpbml0aW9uID0gUnVsZUNvbnRhaW5lci5nZXRSdWxlRGVmaW5pdGlvbihydWxlKTtcclxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtcykpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zLmZpbHRlcihmdW5jdGlvbiAoXywgaWR4KSB7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZpbml0aW9uLnBhcmFtcyAmJiBmaW5kKGRlZmluaXRpb24ucGFyYW1zLCBmdW5jdGlvbiAocCwgaSkgeyByZXR1cm4gISFwLmlzVGFyZ2V0ICYmIGkgPT09IGlkeDsgfSk7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMocGFyYW1zKVxyXG4gICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBkZWZpbml0aW9uLnBhcmFtcyAmJiBmaW5kKGRlZmluaXRpb24ucGFyYW1zLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gISFwLmlzVGFyZ2V0ICYmIHAubmFtZSA9PT0ga2V5OyB9KTtcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBwYXJhbXNba2V5XTsgfSk7XHJcbiAgICAgIH07XHJcbiAgICAgIFJ1bGVDb250YWluZXIuZ2V0UnVsZURlZmluaXRpb24gPSBmdW5jdGlvbiAocnVsZU5hbWUpIHtcclxuICAgICAgICAgIHJldHVybiBSVUxFU1tydWxlTmFtZV07XHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBSdWxlQ29udGFpbmVyO1xyXG4gIH0oKSk7XHJcbiAgLyoqXHJcbiAgICogQWRkcyBhIGN1c3RvbSB2YWxpZGF0b3IgdG8gdGhlIGxpc3Qgb2YgdmFsaWRhdGlvbiBydWxlcy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBleHRlbmQobmFtZSwgc2NoZW1hKSB7XHJcbiAgICAgIC8vIG1ha2VzIHN1cmUgbmV3IHJ1bGVzIGFyZSBwcm9wZXJseSBmb3JtYXR0ZWQuXHJcbiAgICAgIGd1YXJkRXh0ZW5kKG5hbWUsIHNjaGVtYSk7XHJcbiAgICAgIC8vIEZ1bGwgc2NoZW1hIG9iamVjdC5cclxuICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICBSdWxlQ29udGFpbmVyLmV4dGVuZChuYW1lLCBzY2hlbWEpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIFJ1bGVDb250YWluZXIuZXh0ZW5kKG5hbWUsIHtcclxuICAgICAgICAgIHZhbGlkYXRlOiBzY2hlbWFcclxuICAgICAgfSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEd1YXJkcyBmcm9tIGV4dGVuc2lvbiB2aW9sYXRpb25zLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGd1YXJkRXh0ZW5kKG5hbWUsIHZhbGlkYXRvcikge1xyXG4gICAgICBpZiAoaXNDYWxsYWJsZSh2YWxpZGF0b3IpKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGlzQ2FsbGFibGUodmFsaWRhdG9yLnZhbGlkYXRlKSkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChSdWxlQ29udGFpbmVyLmdldFJ1bGVEZWZpbml0aW9uKG5hbWUpKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXh0ZW5zaW9uIEVycm9yOiBUaGUgdmFsaWRhdG9yICdcIiArIG5hbWUgKyBcIicgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGhhdmUgYSAndmFsaWRhdGUnIG1ldGhvZC5cIik7XHJcbiAgfVxuXG4gIHZhciBERUZBVUxUX0NPTkZJRyA9IHtcclxuICAgICAgZGVmYXVsdE1lc3NhZ2U6IFwie19maWVsZF99IGlzIG5vdCB2YWxpZC5cIixcclxuICAgICAgc2tpcE9wdGlvbmFsOiB0cnVlLFxyXG4gICAgICBjbGFzc2VzOiB7XHJcbiAgICAgICAgICB0b3VjaGVkOiAndG91Y2hlZCcsXHJcbiAgICAgICAgICB1bnRvdWNoZWQ6ICd1bnRvdWNoZWQnLFxyXG4gICAgICAgICAgdmFsaWQ6ICd2YWxpZCcsXHJcbiAgICAgICAgICBpbnZhbGlkOiAnaW52YWxpZCcsXHJcbiAgICAgICAgICBwcmlzdGluZTogJ3ByaXN0aW5lJyxcclxuICAgICAgICAgIGRpcnR5OiAnZGlydHknIC8vIGNvbnRyb2wgaGFzIGJlZW4gaW50ZXJhY3RlZCB3aXRoXHJcbiAgICAgIH0sXHJcbiAgICAgIGJhaWxzOiB0cnVlLFxyXG4gICAgICBtb2RlOiAnYWdncmVzc2l2ZScsXHJcbiAgICAgIHVzZUNvbnN0cmFpbnRBdHRyczogdHJ1ZVxyXG4gIH07XHJcbiAgdmFyIGN1cnJlbnRDb25maWcgPSBfX2Fzc2lnbih7fSwgREVGQVVMVF9DT05GSUcpO1xyXG4gIHZhciBnZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjdXJyZW50Q29uZmlnOyB9O1xyXG4gIHZhciBzZXRDb25maWcgPSBmdW5jdGlvbiAobmV3Q29uZikge1xyXG4gICAgICBjdXJyZW50Q29uZmlnID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGN1cnJlbnRDb25maWcpLCBuZXdDb25mKTtcclxuICB9O1xyXG4gIHZhciBjb25maWd1cmUgPSBmdW5jdGlvbiAoY2ZnKSB7XHJcbiAgICAgIHNldENvbmZpZyhjZmcpO1xyXG4gIH07XG5cbiAgdmFyIERpY3Rpb25hcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGZ1bmN0aW9uIERpY3Rpb25hcnkobG9jYWxlLCBkaWN0aW9uYXJ5KSB7XHJcbiAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHt9O1xyXG4gICAgICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7XHJcbiAgICAgICAgICB0aGlzLm1lcmdlKGRpY3Rpb25hcnkpO1xyXG4gICAgICB9XHJcbiAgICAgIERpY3Rpb25hcnkucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAoZmllbGQsIHJ1bGUsIHZhbHVlcykge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KHRoaXMubG9jYWxlLCBmaWVsZCwgcnVsZSwgdmFsdWVzKTtcclxuICAgICAgfTtcclxuICAgICAgRGljdGlvbmFyeS5wcm90b3R5cGUuX2hhc0xvY2FsZSA9IGZ1bmN0aW9uIChsb2NhbGUpIHtcclxuICAgICAgICAgIHJldHVybiAhIXRoaXMuY29udGFpbmVyW2xvY2FsZV07XHJcbiAgICAgIH07XHJcbiAgICAgIERpY3Rpb25hcnkucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uIChsb2NhbGUsIGZpZWxkLCBydWxlLCB2YWx1ZXMpIHtcclxuICAgICAgICAgIHZhciBtZXNzYWdlO1xyXG4gICAgICAgICAgLy8gZmluZCBpZiBzcGVjaWZpYyBtZXNzYWdlIGZvciB0aGF0IGZpZWxkIHdhcyBzcGVjaWZpZWQuXHJcbiAgICAgICAgICB2YXIgZGljdCA9IHRoaXMuY29udGFpbmVyW2xvY2FsZV0gJiYgdGhpcy5jb250YWluZXJbbG9jYWxlXS5maWVsZHMgJiYgdGhpcy5jb250YWluZXJbbG9jYWxlXS5maWVsZHNbZmllbGRdO1xyXG4gICAgICAgICAgaWYgKGRpY3QgJiYgZGljdFtydWxlXSkge1xyXG4gICAgICAgICAgICAgIG1lc3NhZ2UgPSBkaWN0W3J1bGVdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCFtZXNzYWdlICYmIHRoaXMuX2hhc0xvY2FsZShsb2NhbGUpICYmIHRoaXMuX2hhc01lc3NhZ2UobG9jYWxlLCBydWxlKSkge1xyXG4gICAgICAgICAgICAgIG1lc3NhZ2UgPSB0aGlzLmNvbnRhaW5lcltsb2NhbGVdLm1lc3NhZ2VzW3J1bGVdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCFtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgbWVzc2FnZSA9IGdldENvbmZpZygpLmRlZmF1bHRNZXNzYWdlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHRoaXMuX2hhc05hbWUobG9jYWxlLCBmaWVsZCkpIHtcclxuICAgICAgICAgICAgICBmaWVsZCA9IHRoaXMuZ2V0TmFtZShsb2NhbGUsIGZpZWxkKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBpc0NhbGxhYmxlKG1lc3NhZ2UpID8gbWVzc2FnZShmaWVsZCwgdmFsdWVzKSA6IGludGVycG9sYXRlKG1lc3NhZ2UsIF9fYXNzaWduKF9fYXNzaWduKHt9LCB2YWx1ZXMpLCB7IF9maWVsZF86IGZpZWxkIH0pKTtcclxuICAgICAgfTtcclxuICAgICAgRGljdGlvbmFyeS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiAoZGljdGlvbmFyeSkge1xyXG4gICAgICAgICAgbWVyZ2UodGhpcy5jb250YWluZXIsIGRpY3Rpb25hcnkpO1xyXG4gICAgICB9O1xyXG4gICAgICBEaWN0aW9uYXJ5LnByb3RvdHlwZS5oYXNSdWxlID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgIHZhciBsb2NhbGUgPSB0aGlzLmNvbnRhaW5lclt0aGlzLmxvY2FsZV07XHJcbiAgICAgICAgICBpZiAoIWxvY2FsZSlcclxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICByZXR1cm4gISEobG9jYWxlLm1lc3NhZ2VzICYmIGxvY2FsZS5tZXNzYWdlc1tuYW1lXSk7XHJcbiAgICAgIH07XHJcbiAgICAgIERpY3Rpb25hcnkucHJvdG90eXBlLmdldE5hbWUgPSBmdW5jdGlvbiAobG9jYWxlLCBrZXkpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcltsb2NhbGVdLm5hbWVzW2tleV07XHJcbiAgICAgIH07XHJcbiAgICAgIERpY3Rpb25hcnkucHJvdG90eXBlLl9oYXNNZXNzYWdlID0gZnVuY3Rpb24gKGxvY2FsZSwga2V5KSB7XHJcbiAgICAgICAgICByZXR1cm4gISEodGhpcy5faGFzTG9jYWxlKGxvY2FsZSkgJiYgdGhpcy5jb250YWluZXJbbG9jYWxlXS5tZXNzYWdlcyAmJiB0aGlzLmNvbnRhaW5lcltsb2NhbGVdLm1lc3NhZ2VzW2tleV0pO1xyXG4gICAgICB9O1xyXG4gICAgICBEaWN0aW9uYXJ5LnByb3RvdHlwZS5faGFzTmFtZSA9IGZ1bmN0aW9uIChsb2NhbGUsIGtleSkge1xyXG4gICAgICAgICAgcmV0dXJuICEhKHRoaXMuX2hhc0xvY2FsZShsb2NhbGUpICYmIHRoaXMuY29udGFpbmVyW2xvY2FsZV0ubmFtZXMgJiYgdGhpcy5jb250YWluZXJbbG9jYWxlXS5uYW1lc1trZXldKTtcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIERpY3Rpb25hcnk7XHJcbiAgfSgpKTtcclxuICB2YXIgRElDVElPTkFSWTtcclxuICB2YXIgSU5TVEFMTEVEID0gZmFsc2U7XHJcbiAgZnVuY3Rpb24gdXBkYXRlUnVsZXMoKSB7XHJcbiAgICAgIGlmIChJTlNUQUxMRUQpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBSdWxlQ29udGFpbmVyLml0ZXJhdGUoZnVuY3Rpb24gKG5hbWUsIHNjaGVtYSkge1xyXG4gICAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICAgIGlmIChzY2hlbWEubWVzc2FnZSAmJiAhRElDVElPTkFSWS5oYXNSdWxlKG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgRElDVElPTkFSWS5tZXJnZSgoX2EgPSB7fSxcclxuICAgICAgICAgICAgICAgICAgX2FbRElDVElPTkFSWS5sb2NhbGVdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXM6IChfYiA9IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9iW25hbWVdID0gc2NoZW1hLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2IpXHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgIF9hKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBleHRlbmQobmFtZSwge1xyXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGZ1bmN0aW9uIChmaWVsZCwgdmFsdWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBESUNUSU9OQVJZLnJlc29sdmUoZmllbGQsIG5hbWUsIHZhbHVlcyB8fCB7fSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBJTlNUQUxMRUQgPSB0cnVlO1xyXG4gIH1cclxuICBmdW5jdGlvbiBsb2NhbGl6ZShsb2NhbGUsIGRpY3Rpb25hcnkpIHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICBpZiAoIURJQ1RJT05BUlkpIHtcclxuICAgICAgICAgIERJQ1RJT05BUlkgPSBuZXcgRGljdGlvbmFyeSgnZW4nLCB7fSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHR5cGVvZiBsb2NhbGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICBESUNUSU9OQVJZLmxvY2FsZSA9IGxvY2FsZTtcclxuICAgICAgICAgIGlmIChkaWN0aW9uYXJ5KSB7XHJcbiAgICAgICAgICAgICAgRElDVElPTkFSWS5tZXJnZSgoX2EgPSB7fSwgX2FbbG9jYWxlXSA9IGRpY3Rpb25hcnksIF9hKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB1cGRhdGVSdWxlcygpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIERJQ1RJT05BUlkubWVyZ2UobG9jYWxlKTtcclxuICAgICAgdXBkYXRlUnVsZXMoKTtcclxuICB9XG5cbiAgdmFyIGFnZ3Jlc3NpdmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xyXG4gICAgICBvbjogWydpbnB1dCcsICdibHVyJ11cclxuICB9KTsgfTtcclxuICB2YXIgbGF6eSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XHJcbiAgICAgIG9uOiBbJ2NoYW5nZSddXHJcbiAgfSk7IH07XHJcbiAgdmFyIGVhZ2VyID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgIHZhciBlcnJvcnMgPSBfYS5lcnJvcnM7XHJcbiAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgIG9uOiBbJ2lucHV0JywgJ2NoYW5nZSddXHJcbiAgICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBvbjogWydjaGFuZ2UnLCAnYmx1ciddXHJcbiAgICAgIH07XHJcbiAgfTtcclxuICB2YXIgcGFzc2l2ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XHJcbiAgICAgIG9uOiBbXVxyXG4gIH0pOyB9O1xyXG4gIHZhciBtb2RlcyA9IHtcclxuICAgICAgYWdncmVzc2l2ZTogYWdncmVzc2l2ZSxcclxuICAgICAgZWFnZXI6IGVhZ2VyLFxyXG4gICAgICBwYXNzaXZlOiBwYXNzaXZlLFxyXG4gICAgICBsYXp5OiBsYXp5XHJcbiAgfTtcclxuICB2YXIgc2V0SW50ZXJhY3Rpb25Nb2RlID0gZnVuY3Rpb24gKG1vZGUsIGltcGxlbWVudGF0aW9uKSB7XHJcbiAgICAgIHNldENvbmZpZyh7IG1vZGU6IG1vZGUgfSk7XHJcbiAgICAgIGlmICghaW1wbGVtZW50YXRpb24pIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWlzQ2FsbGFibGUoaW1wbGVtZW50YXRpb24pKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgbW9kZSBpbXBsZW1lbnRhdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcclxuICAgICAgfVxyXG4gICAgICBtb2Rlc1ttb2RlXSA9IGltcGxlbWVudGF0aW9uO1xyXG4gIH07XG5cbiAgLyoqXHJcbiAgICogVmFsaWRhdGVzIGEgdmFsdWUgYWdhaW5zdCB0aGUgcnVsZXMuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gdmFsaWRhdGUkcih2YWx1ZSwgcnVsZXMsIG9wdGlvbnMpIHtcclxuICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgdmFyIHNob3VsZEJhaWwsIHNraXBJZkVtcHR5LCBmaWVsZCwgcmVzdWx0LCBlcnJvcnMsIHJ1bGVNYXA7XHJcbiAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICBzaG91bGRCYWlsID0gb3B0aW9ucyAmJiBvcHRpb25zLmJhaWxzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgc2tpcElmRW1wdHkgPSBvcHRpb25zICYmIG9wdGlvbnMuc2tpcElmRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICBmaWVsZCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAob3B0aW9ucyAmJiBvcHRpb25zLm5hbWUpIHx8ICd7ZmllbGR9JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlczogbm9ybWFsaXplUnVsZXMocnVsZXMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJhaWxzOiBpc051bGxPclVuZGVmaW5lZChzaG91bGRCYWlsKSA/IHRydWUgOiBzaG91bGRCYWlsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBJZkVtcHR5OiBpc051bGxPclVuZGVmaW5lZChza2lwSWZFbXB0eSkgPyB0cnVlIDogc2tpcElmRW1wdHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VSZXF1aXJlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY3Jvc3NUYWJsZTogKG9wdGlvbnMgJiYgb3B0aW9ucy52YWx1ZXMpIHx8IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzOiAob3B0aW9ucyAmJiBvcHRpb25zLm5hbWVzKSB8fCB7fSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21NZXNzYWdlczogKG9wdGlvbnMgJiYgb3B0aW9ucy5jdXN0b21NZXNzYWdlcykgfHwge31cclxuICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfdmFsaWRhdGUoZmllbGQsIHZhbHVlLCBvcHRpb25zKV07XHJcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgcnVsZU1hcCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZS5tc2cpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVNYXBbZS5ydWxlXSA9IGUubXNnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZDogcmVzdWx0LnZhbGlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IGVycm9ycyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbGVkUnVsZXM6IHJ1bGVNYXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0cyB0aGUgdmFsaWRhdGlvbiBwcm9jZXNzLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIF92YWxpZGF0ZShmaWVsZCwgdmFsdWUsIF9hKSB7XHJcbiAgICAgIHZhciBfYiA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkuaXNJbml0aWFsLCBpc0luaXRpYWwgPSBfYiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYjtcclxuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgdmFyIF9jLCBzaG91bGRTa2lwLCBlcnJvcnMsIHJ1bGVzLCBsZW5ndGgsIGksIHJ1bGUsIHJlc3VsdDtcclxuICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2QpIHtcclxuICAgICAgICAgICAgICBzd2l0Y2ggKF9kLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgX3Nob3VsZFNraXAoZmllbGQsIHZhbHVlKV07XHJcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgIF9jID0gX2Quc2VudCgpLCBzaG91bGRTa2lwID0gX2Muc2hvdWxkU2tpcCwgZXJyb3JzID0gX2MuZXJyb3JzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFNraXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQ6ICFlcnJvcnMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiBlcnJvcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfV07XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICBydWxlcyA9IE9iamVjdC5rZXlzKGZpZWxkLnJ1bGVzKS5maWx0ZXIoZnVuY3Rpb24gKHJ1bGUpIHsgcmV0dXJuICFSdWxlQ29udGFpbmVyLmlzUmVxdWlyZVJ1bGUocnVsZSk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gcnVsZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICBfZC5sYWJlbCA9IDI7XHJcbiAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgIGlmICghKGkgPCBsZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCA1XTtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0luaXRpYWwgJiYgUnVsZUNvbnRhaW5lci5pc0xhenkocnVsZXNbaV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICBydWxlID0gcnVsZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfdGVzdChmaWVsZCwgdmFsdWUsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcnVsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBmaWVsZC5ydWxlc1tydWxlXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcclxuICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Quc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQudmFsaWQgJiYgcmVzdWx0LmVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gocmVzdWx0LmVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQuYmFpbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiBlcnJvcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIF9kLmxhYmVsID0gNDtcclxuICAgICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XHJcbiAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZDogIWVycm9ycy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiBlcnJvcnNcclxuICAgICAgICAgICAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gX3Nob3VsZFNraXAoZmllbGQsIHZhbHVlKSB7XHJcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHZhciByZXF1aXJlUnVsZXMsIGxlbmd0aCwgZXJyb3JzLCBpc0VtcHR5LCBpc0VtcHR5QW5kT3B0aW9uYWwsIGlzUmVxdWlyZWQsIGksIHJ1bGUsIHJlc3VsdDtcclxuICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVSdWxlcyA9IE9iamVjdC5rZXlzKGZpZWxkLnJ1bGVzKS5maWx0ZXIoUnVsZUNvbnRhaW5lci5pc1JlcXVpcmVSdWxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IHJlcXVpcmVSdWxlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgIGlzRW1wdHkgPSBpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkgfHwgdmFsdWUgPT09ICcnIHx8IGlzRW1wdHlBcnJheSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpc0VtcHR5QW5kT3B0aW9uYWwgPSBpc0VtcHR5ICYmIGZpZWxkLnNraXBJZkVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgaXNSZXF1aXJlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgIGlmICghKGkgPCBsZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcclxuICAgICAgICAgICAgICAgICAgICAgIHJ1bGUgPSByZXF1aXJlUnVsZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfdGVzdChmaWVsZCwgdmFsdWUsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcnVsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBmaWVsZC5ydWxlc1tydWxlXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcclxuICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc09iamVjdChyZXN1bHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1aXJlIHJ1bGVzIGhhcyB0byByZXR1cm4gYW4gb2JqZWN0IChzZWUgZG9jcyknKTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVxdWlyZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBpc1JlcXVpcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LnZhbGlkICYmIHJlc3VsdC5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHJlc3VsdC5lcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhpdCBlYXJseSBhcyB0aGUgZmllbGQgaXMgcmVxdWlyZWQgYW5kIGZhaWxlZCB2YWxpZGF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZC5iYWlscykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFNraXA6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiBlcnJvcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcclxuICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XHJcbiAgICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5ICYmICFpc1JlcXVpcmVkICYmICFmaWVsZC5za2lwSWZFbXB0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRTa2lwOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yczogZXJyb3JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZmllbGQgaXMgY29uZmlndXJlZCB0byBydW4gdGhyb3VnaCB0aGUgcGlwZWxpbmUgcmVnYXJkbGVzc1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZC5iYWlscyAmJiAhaXNFbXB0eUFuZE9wdGlvbmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFNraXA6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiBlcnJvcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfV07XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBza2lwIGlmIHRoZSBmaWVsZCBpcyBub3QgcmVxdWlyZWQgYW5kIGhhcyBhbiBlbXB0eSB2YWx1ZS5cclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFNraXA6ICFpc1JlcXVpcmVkICYmIGlzRW1wdHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yczogZXJyb3JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfV07XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBUZXN0cyBhIHNpbmdsZSBpbnB1dCB2YWx1ZSBhZ2FpbnN0IGEgcnVsZS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBfdGVzdChmaWVsZCwgdmFsdWUsIHJ1bGUpIHtcclxuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgdmFyIHJ1bGVTY2hlbWEsIHBhcmFtcywgbm9ybWFsaXplZFZhbHVlLCByZXN1bHQsIHZhbHVlcztcclxuICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgIHJ1bGVTY2hlbWEgPSBSdWxlQ29udGFpbmVyLmdldFJ1bGVEZWZpbml0aW9uKHJ1bGUubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJ1bGVTY2hlbWEgfHwgIXJ1bGVTY2hlbWEudmFsaWRhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdWNoIHZhbGlkYXRvciAnXCIgKyBydWxlLm5hbWUgKyBcIicgZXhpc3RzLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IF9idWlsZFBhcmFtcyhydWxlLnBhcmFtcywgcnVsZVNjaGVtYS5wYXJhbXMsIGZpZWxkLmNyb3NzVGFibGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZFZhbHVlID0gcnVsZVNjaGVtYS5jYXN0VmFsdWUgPyBydWxlU2NoZW1hLmNhc3RWYWx1ZSh2YWx1ZSkgOiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJ1bGVTY2hlbWEudmFsaWRhdGUobm9ybWFsaXplZFZhbHVlLCBwYXJhbXMpXTtcclxuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIChwYXJhbXMgfHwge30pKSwgeyBfZmllbGRfOiBmaWVsZC5uYW1lLCBfdmFsdWVfOiB2YWx1ZSwgX3J1bGVfOiBydWxlLm5hbWUgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiB7IHJ1bGU6IHJ1bGUubmFtZSwgbXNnOiBpbnRlcnBvbGF0ZShyZXN1bHQsIHZhbHVlcykgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNPYmplY3QocmVzdWx0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHsgdmFsaWQ6IHJlc3VsdCwgZGF0YToge30gfTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkOiByZXN1bHQudmFsaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiByZXN1bHQucmVxdWlyZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHJlc3VsdC5kYXRhIHx8IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogcmVzdWx0LnZhbGlkID8gdW5kZWZpbmVkIDogX2dlbmVyYXRlRmllbGRFcnJvcihmaWVsZCwgdmFsdWUsIHJ1bGVTY2hlbWEsIHJ1bGUubmFtZSwgcGFyYW1zLCByZXN1bHQuZGF0YSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlcyBlcnJvciBtZXNzYWdlcy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBfZ2VuZXJhdGVGaWVsZEVycm9yKGZpZWxkLCB2YWx1ZSwgcnVsZVNjaGVtYSwgcnVsZU5hbWUsIHBhcmFtcywgZGF0YSkge1xyXG4gICAgICB2YXIgdmFsdWVzID0gX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oe30sIChwYXJhbXMgfHwge30pKSwgKGRhdGEgfHwge30pKSwgeyBfZmllbGRfOiBmaWVsZC5uYW1lLCBfdmFsdWVfOiB2YWx1ZSwgX3J1bGVfOiBydWxlTmFtZSB9KSwgX2dldFRhcmdldE5hbWVzKGZpZWxkLCBydWxlU2NoZW1hLCBydWxlTmFtZSkpO1xyXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGZpZWxkLmN1c3RvbU1lc3NhZ2VzLCBydWxlTmFtZSkgJiZcclxuICAgICAgICAgIHR5cGVvZiBmaWVsZC5jdXN0b21NZXNzYWdlc1tydWxlTmFtZV0gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgIG1zZzogX25vcm1hbGl6ZU1lc3NhZ2UoZmllbGQuY3VzdG9tTWVzc2FnZXNbcnVsZU5hbWVdLCBmaWVsZC5uYW1lLCB2YWx1ZXMpLFxyXG4gICAgICAgICAgICAgIHJ1bGU6IHJ1bGVOYW1lXHJcbiAgICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChydWxlU2NoZW1hLm1lc3NhZ2UpIHtcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgbXNnOiBfbm9ybWFsaXplTWVzc2FnZShydWxlU2NoZW1hLm1lc3NhZ2UsIGZpZWxkLm5hbWUsIHZhbHVlcyksXHJcbiAgICAgICAgICAgICAgcnVsZTogcnVsZU5hbWVcclxuICAgICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIG1zZzogX25vcm1hbGl6ZU1lc3NhZ2UoZ2V0Q29uZmlnKCkuZGVmYXVsdE1lc3NhZ2UsIGZpZWxkLm5hbWUsIHZhbHVlcyksXHJcbiAgICAgICAgICBydWxlOiBydWxlTmFtZVxyXG4gICAgICB9O1xyXG4gIH1cclxuICBmdW5jdGlvbiBfZ2V0VGFyZ2V0TmFtZXMoZmllbGQsIHJ1bGVTY2hlbWEsIHJ1bGVOYW1lKSB7XHJcbiAgICAgIGlmIChydWxlU2NoZW1hLnBhcmFtcykge1xyXG4gICAgICAgICAgdmFyIG51bVRhcmdldHMgPSBydWxlU2NoZW1hLnBhcmFtcy5maWx0ZXIoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbS5pc1RhcmdldDsgfSkubGVuZ3RoO1xyXG4gICAgICAgICAgaWYgKG51bVRhcmdldHMgPiAwKSB7XHJcbiAgICAgICAgICAgICAgdmFyIG5hbWVzID0ge307XHJcbiAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHJ1bGVTY2hlbWEucGFyYW1zLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgICB2YXIgcGFyYW0gPSBydWxlU2NoZW1hLnBhcmFtc1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJhbS5pc1RhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGZpZWxkLnJ1bGVzW3J1bGVOYW1lXVtpbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZV8xID0gZmllbGQubmFtZXNba2V5XSB8fCBrZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobnVtVGFyZ2V0cyA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzLl90YXJnZXRfID0gbmFtZV8xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXNbXCJfXCIgKyBwYXJhbS5uYW1lICsgXCJUYXJnZXRfXCJdID0gbmFtZV8xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHJldHVybiBuYW1lcztcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4ge307XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIF9ub3JtYWxpemVNZXNzYWdlKHRlbXBsYXRlLCBmaWVsZCwgdmFsdWVzKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZShmaWVsZCwgdmFsdWVzKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gaW50ZXJwb2xhdGUodGVtcGxhdGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCB2YWx1ZXMpLCB7IF9maWVsZF86IGZpZWxkIH0pKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gX2J1aWxkUGFyYW1zKHByb3ZpZGVkLCBkZWZpbmVkLCBjcm9zc1RhYmxlKSB7XHJcbiAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgaWYgKCFkZWZpbmVkICYmICFBcnJheS5pc0FycmF5KHByb3ZpZGVkKSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYW4gb2JqZWN0IHBhcmFtcyB0byBhIHJ1bGUgdGhhdCBoYXMgbm8gZGVmaW5lZCBzY2hlbWEuJyk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gUnVsZSBwcm9iYWJseSB1c2VzIGFuIGFycmF5IGZvciB0aGVpciBhcmdzLCBrZWVwIGl0IGFzIGlzLlxyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm92aWRlZCkgJiYgIWRlZmluZWQpIHtcclxuICAgICAgICAgIHJldHVybiBwcm92aWRlZDtcclxuICAgICAgfVxyXG4gICAgICB2YXIgZGVmaW5lZFJ1bGVzO1xyXG4gICAgICAvLyBjb2xsZWN0IHRoZSBwYXJhbXMgc2NoZW1hLlxyXG4gICAgICBpZiAoIWRlZmluZWQgfHwgZGVmaW5lZC5sZW5ndGggPCBwcm92aWRlZC5sZW5ndGgpIHtcclxuICAgICAgICAgIHZhciBsYXN0RGVmaW5lZFBhcmFtXzE7XHJcbiAgICAgICAgICAvLyBjb2xsZWN0IGFueSBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgaW4gdGhlIGxhc3QgaXRlbS5cclxuICAgICAgICAgIGRlZmluZWRSdWxlcyA9IHByb3ZpZGVkLm1hcChmdW5jdGlvbiAoXywgaWR4KSB7XHJcbiAgICAgICAgICAgICAgdmFyIHBhcmFtID0gZGVmaW5lZCAmJiBkZWZpbmVkW2lkeF07XHJcbiAgICAgICAgICAgICAgbGFzdERlZmluZWRQYXJhbV8xID0gcGFyYW0gfHwgbGFzdERlZmluZWRQYXJhbV8xO1xyXG4gICAgICAgICAgICAgIGlmICghcGFyYW0pIHtcclxuICAgICAgICAgICAgICAgICAgcGFyYW0gPSBsYXN0RGVmaW5lZFBhcmFtXzE7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHJldHVybiBwYXJhbTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgZGVmaW5lZFJ1bGVzID0gZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgICAvLyBNYXRjaCB0aGUgcHJvdmlkZWQgYXJyYXkgbGVuZ3RoIHdpdGggYSB0ZW1wb3Jhcnkgc2NoZW1hLlxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlZmluZWRSdWxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSBkZWZpbmVkUnVsZXNbaV07XHJcbiAgICAgICAgICB2YXIgdmFsdWUgPSBvcHRpb25zLmRlZmF1bHQ7XHJcbiAgICAgICAgICAvLyBpZiB0aGUgcHJvdmlkZWQgaXMgYW4gYXJyYXksIG1hcCBlbGVtZW50IHZhbHVlLlxyXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvdmlkZWQpKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGkgaW4gcHJvdmlkZWQpIHtcclxuICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcm92aWRlZFtpXTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAvLyBJZiB0aGUgcGFyYW0gZXhpc3RzIGluIHRoZSBwcm92aWRlZCBvYmplY3QuXHJcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubmFtZSBpbiBwcm92aWRlZCkge1xyXG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IHByb3ZpZGVkW29wdGlvbnMubmFtZV07XHJcbiAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBwcm92aWRlZCBpcyB0aGUgZmlyc3QgcGFyYW0gdmFsdWUuXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGVsc2UgaWYgKGRlZmluZWRSdWxlcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcm92aWRlZDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBpZiB0aGUgcGFyYW0gaXMgYSB0YXJnZXQsIHJlc29sdmUgdGhlIHRhcmdldCB2YWx1ZS5cclxuICAgICAgICAgIGlmIChvcHRpb25zLmlzVGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgdmFsdWUgPSBjcm9zc1RhYmxlW3ZhbHVlXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgdHJhbnNmb3JtZXIgZGVmaW5lZC5cclxuICAgICAgICAgIGlmIChvcHRpb25zLmNhc3QpIHtcclxuICAgICAgICAgICAgICB2YWx1ZSA9IG9wdGlvbnMuY2FzdCh2YWx1ZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBhbHJlYWR5IGJlZW4gc2V0LCBwcm9iYWJseSBtdWx0aXBsZSB2YWx1ZXMuXHJcbiAgICAgICAgICBpZiAocGFyYW1zW29wdGlvbnMubmFtZV0pIHtcclxuICAgICAgICAgICAgICBwYXJhbXNbb3B0aW9ucy5uYW1lXSA9IEFycmF5LmlzQXJyYXkocGFyYW1zW29wdGlvbnMubmFtZV0pID8gcGFyYW1zW29wdGlvbnMubmFtZV0gOiBbcGFyYW1zW29wdGlvbnMubmFtZV1dO1xyXG4gICAgICAgICAgICAgIHBhcmFtc1tvcHRpb25zLm5hbWVdLnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgLy8gc2V0IHRoZSB2YWx1ZS5cclxuICAgICAgICAgICAgICBwYXJhbXNbb3B0aW9ucy5uYW1lXSA9IHZhbHVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBwYXJhbXM7XHJcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc3RhbGwoXywgY29uZmlnKSB7XHJcbiAgICAgIHNldENvbmZpZyhjb25maWcpO1xyXG4gIH1cblxuICB2YXIgaXNFdmVudCA9IGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgaWYgKCFldnQpIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodHlwZW9mIEV2ZW50ICE9PSAndW5kZWZpbmVkJyAmJiBpc0NhbGxhYmxlKEV2ZW50KSAmJiBldnQgaW5zdGFuY2VvZiBFdmVudCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgLy8gdGhpcyBpcyBmb3IgSUVcclxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgaWYgKGV2dCAmJiBldnQuc3JjRWxlbWVudCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gIH07XHJcbiAgZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRWYWx1ZSh2YWx1ZSkge1xyXG4gICAgICBpZiAoIWlzRXZlbnQodmFsdWUpKSB7XHJcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGlucHV0ID0gdmFsdWUudGFyZ2V0O1xyXG4gICAgICBpZiAoaW5wdXQudHlwZSA9PT0gJ2ZpbGUnICYmIGlucHV0LmZpbGVzKSB7XHJcbiAgICAgICAgICByZXR1cm4gdG9BcnJheShpbnB1dC5maWxlcyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGlucHV0LnZhbHVlO1xyXG4gIH1cblxuICB2YXIgaXNUZXh0SW5wdXQgPSBmdW5jdGlvbiAodm5vZGUpIHtcclxuICAgICAgdmFyIGF0dHJzID0gKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycykgfHwgdm5vZGUuZWxtO1xyXG4gICAgICAvLyBpdCB3aWxsIGZhbGxiYWNrIHRvIGJlaW5nIGEgdGV4dCBpbnB1dCBwZXIgYnJvd3NlcnMgc3BlYy5cclxuICAgICAgaWYgKHZub2RlLnRhZyA9PT0gJ2lucHV0JyAmJiAoIWF0dHJzIHx8ICFhdHRycy50eXBlKSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHZub2RlLnRhZyA9PT0gJ3RleHRhcmVhJykge1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGluY2x1ZGVzKFsndGV4dCcsICdwYXNzd29yZCcsICdzZWFyY2gnLCAnZW1haWwnLCAndGVsJywgJ3VybCcsICdudW1iZXInXSwgYXR0cnMgJiYgYXR0cnMudHlwZSk7XHJcbiAgfTtcclxuICAvLyBleHBvcnQgY29uc3QgaXNDaGVja2JveE9yUmFkaW9JbnB1dCA9ICh2bm9kZTogVk5vZGUpOiBib29sZWFuID0+IHtcclxuICAvLyAgIGNvbnN0IGF0dHJzID0gKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycykgfHwgdm5vZGUuZWxtO1xyXG4gIC8vICAgcmV0dXJuIGluY2x1ZGVzKFsncmFkaW8nLCAnY2hlY2tib3gnXSwgYXR0cnMgJiYgYXR0cnMudHlwZSk7XHJcbiAgLy8gfTtcclxuICAvLyBHZXRzIHRoZSBtb2RlbCBvYmplY3Qgb24gdGhlIHZub2RlLlxyXG4gIGZ1bmN0aW9uIGZpbmRNb2RlbCh2bm9kZSkge1xyXG4gICAgICBpZiAoIXZub2RlLmRhdGEpIHtcclxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgICAgLy8gQ29tcG9uZW50IE1vZGVsXHJcbiAgICAgIC8vIFRISVMgSVMgTk9UIFRZUEVEIElOIE9GRklDSUFMIFZVRSBUWVBJTkdTXHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG4gICAgICB2YXIgbm9uU3RhbmRhcmRWTm9kZURhdGEgPSB2bm9kZS5kYXRhO1xyXG4gICAgICBpZiAoJ21vZGVsJyBpbiBub25TdGFuZGFyZFZOb2RlRGF0YSkge1xyXG4gICAgICAgICAgcmV0dXJuIG5vblN0YW5kYXJkVk5vZGVEYXRhLm1vZGVsO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XHJcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmaW5kKHZub2RlLmRhdGEuZGlyZWN0aXZlcywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubmFtZSA9PT0gJ21vZGVsJzsgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGZpbmRWYWx1ZSh2bm9kZSkge1xyXG4gICAgICB2YXIgbW9kZWwgPSBmaW5kTW9kZWwodm5vZGUpO1xyXG4gICAgICBpZiAobW9kZWwpIHtcclxuICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBtb2RlbC52YWx1ZSB9O1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBjb25maWcgPSBmaW5kTW9kZWxDb25maWcodm5vZGUpO1xyXG4gICAgICB2YXIgcHJvcCA9IChjb25maWcgJiYgY29uZmlnLnByb3ApIHx8ICd2YWx1ZSc7XHJcbiAgICAgIGlmICh2bm9kZS5jb21wb25lbnRPcHRpb25zICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhICYmIHByb3AgaW4gdm5vZGUuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGEpIHtcclxuICAgICAgICAgIHZhciBwcm9wc0RhdGFXaXRoVmFsdWUgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zLnByb3BzRGF0YTtcclxuICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBwcm9wc0RhdGFXaXRoVmFsdWVbcHJvcF0gfTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmRvbVByb3BzICYmICd2YWx1ZScgaW4gdm5vZGUuZGF0YS5kb21Qcm9wcykge1xyXG4gICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZub2RlLmRhdGEuZG9tUHJvcHMudmFsdWUgfTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH1cclxuICBmdW5jdGlvbiBleHRyYWN0Q2hpbGRyZW4odm5vZGUpIHtcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XHJcbiAgICAgICAgICByZXR1cm4gdm5vZGU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUuY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICByZXR1cm4gdm5vZGUuY2hpbGRyZW47XHJcbiAgICAgIH1cclxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgaWYgKHZub2RlLmNvbXBvbmVudE9wdGlvbnMgJiYgQXJyYXkuaXNBcnJheSh2bm9kZS5jb21wb25lbnRPcHRpb25zLmNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgcmV0dXJuIHZub2RlLmNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW47XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuICBmdW5jdGlvbiBleHRyYWN0Vk5vZGVzKHZub2RlKSB7XHJcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2bm9kZSkgJiYgZmluZFZhbHVlKHZub2RlKSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICByZXR1cm4gW3Zub2RlXTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgY2hpbGRyZW4gPSBleHRyYWN0Q2hpbGRyZW4odm5vZGUpO1xyXG4gICAgICByZXR1cm4gY2hpbGRyZW4ucmVkdWNlKGZ1bmN0aW9uIChub2Rlcywgbm9kZSkge1xyXG4gICAgICAgICAgdmFyIGNhbmRpZGF0ZXMgPSBleHRyYWN0Vk5vZGVzKG5vZGUpO1xyXG4gICAgICAgICAgaWYgKGNhbmRpZGF0ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgbm9kZXMucHVzaC5hcHBseShub2RlcywgY2FuZGlkYXRlcyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gbm9kZXM7XHJcbiAgICAgIH0sIFtdKTtcclxuICB9XHJcbiAgLy8gUmVzb2x2ZXMgdi1tb2RlbCBjb25maWcgaWYgZXhpc3RzLlxyXG4gIGZ1bmN0aW9uIGZpbmRNb2RlbENvbmZpZyh2bm9kZSkge1xyXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICBpZiAoIXZub2RlLmNvbXBvbmVudE9wdGlvbnMpXHJcbiAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgLy8gVGhpcyBpcyBhbHNvIG5vdCB0eXBlZCBpbiB0aGUgc3RhbmRhcmQgVnVlIFRTLlxyXG4gICAgICByZXR1cm4gdm5vZGUuY29tcG9uZW50T3B0aW9ucy5DdG9yLm9wdGlvbnMubW9kZWw7XHJcbiAgfVxyXG4gIC8vIEFkZHMgYSBsaXN0ZW5lciB0byB2bm9kZSBsaXN0ZW5lciBvYmplY3QuXHJcbiAgZnVuY3Rpb24gbWVyZ2VWTm9kZUxpc3RlbmVycyhvYmosIGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAvLyBubyBsaXN0ZW5lciBhdCBhbGwuXHJcbiAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZChvYmpbZXZlbnROYW1lXSkpIHtcclxuICAgICAgICAgIG9ialtldmVudE5hbWVdID0gW2hhbmRsZXJdO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIElzIGFuIGludm9rZXIuXHJcbiAgICAgIGlmIChpc0NhbGxhYmxlKG9ialtldmVudE5hbWVdKSAmJiBvYmpbZXZlbnROYW1lXS5mbnMpIHtcclxuICAgICAgICAgIHZhciBpbnZva2VyID0gb2JqW2V2ZW50TmFtZV07XHJcbiAgICAgICAgICBpbnZva2VyLmZucyA9IEFycmF5LmlzQXJyYXkoaW52b2tlci5mbnMpID8gaW52b2tlci5mbnMgOiBbaW52b2tlci5mbnNdO1xyXG4gICAgICAgICAgaWYgKCFpbmNsdWRlcyhpbnZva2VyLmZucywgaGFuZGxlcikpIHtcclxuICAgICAgICAgICAgICBpbnZva2VyLmZucy5wdXNoKGhhbmRsZXIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc0NhbGxhYmxlKG9ialtldmVudE5hbWVdKSkge1xyXG4gICAgICAgICAgdmFyIHByZXYgPSBvYmpbZXZlbnROYW1lXTtcclxuICAgICAgICAgIG9ialtldmVudE5hbWVdID0gW3ByZXZdO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtldmVudE5hbWVdKSAmJiAhaW5jbHVkZXMob2JqW2V2ZW50TmFtZV0sIGhhbmRsZXIpKSB7XHJcbiAgICAgICAgICBvYmpbZXZlbnROYW1lXS5wdXNoKGhhbmRsZXIpO1xyXG4gICAgICB9XHJcbiAgfVxyXG4gIC8vIEFkZHMgYSBsaXN0ZW5lciB0byBhIG5hdGl2ZSBIVE1MIHZub2RlLlxyXG4gIGZ1bmN0aW9uIGFkZE5hdGl2ZU5vZGVMaXN0ZW5lcihub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgaWYgKCFub2RlLmRhdGEpIHtcclxuICAgICAgICAgIG5vZGUuZGF0YSA9IHt9O1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZChub2RlLmRhdGEub24pKSB7XHJcbiAgICAgICAgICBub2RlLmRhdGEub24gPSB7fTtcclxuICAgICAgfVxyXG4gICAgICBtZXJnZVZOb2RlTGlzdGVuZXJzKG5vZGUuZGF0YS5vbiwgZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICB9XHJcbiAgLy8gQWRkcyBhIGxpc3RlbmVyIHRvIGEgVnVlIGNvbXBvbmVudCB2bm9kZS5cclxuICBmdW5jdGlvbiBhZGRDb21wb25lbnROb2RlTGlzdGVuZXIobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgIGlmICghbm9kZS5jb21wb25lbnRPcHRpb25zKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgaWYgKCFub2RlLmNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzKSB7XHJcbiAgICAgICAgICBub2RlLmNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzID0ge307XHJcbiAgICAgIH1cclxuICAgICAgbWVyZ2VWTm9kZUxpc3RlbmVycyhub2RlLmNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzLCBldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gIH1cclxuICBmdW5jdGlvbiBhZGRWTm9kZUxpc3RlbmVyKHZub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgaWYgKHZub2RlLmNvbXBvbmVudE9wdGlvbnMpIHtcclxuICAgICAgICAgIGFkZENvbXBvbmVudE5vZGVMaXN0ZW5lcih2bm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBhZGROYXRpdmVOb2RlTGlzdGVuZXIodm5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgfVxyXG4gIC8vIERldGVybWluZXMgaWYgYGNoYW5nZWAgc2hvdWxkIGJlIHVzZWQgb3ZlciBgaW5wdXRgIGZvciBsaXN0ZW5lcnMuXHJcbiAgZnVuY3Rpb24gZ2V0SW5wdXRFdmVudE5hbWUodm5vZGUsIG1vZGVsKSB7XHJcbiAgICAgIC8vIElzIGEgY29tcG9uZW50LlxyXG4gICAgICBpZiAodm5vZGUuY29tcG9uZW50T3B0aW9ucykge1xyXG4gICAgICAgICAgdmFyIGV2ZW50XzEgPSAoZmluZE1vZGVsQ29uZmlnKHZub2RlKSB8fCB7IGV2ZW50OiAnaW5wdXQnIH0pLmV2ZW50O1xyXG4gICAgICAgICAgcmV0dXJuIGV2ZW50XzE7XHJcbiAgICAgIH1cclxuICAgICAgLy8gTGF6eSBNb2RlbHMgdHlwaWNhbGx5IHVzZSBjaGFuZ2UgZXZlbnRcclxuICAgICAgaWYgKG1vZGVsICYmIG1vZGVsLm1vZGlmaWVycyAmJiBtb2RlbC5tb2RpZmllcnMubGF6eSkge1xyXG4gICAgICAgICAgcmV0dXJuICdjaGFuZ2UnO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIGlzIGEgdGV4dHVhbC10eXBlIGlucHV0LlxyXG4gICAgICBpZiAoaXNUZXh0SW5wdXQodm5vZGUpKSB7XHJcbiAgICAgICAgICByZXR1cm4gJ2lucHV0JztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gJ2NoYW5nZSc7XHJcbiAgfVxyXG4gIC8vIFRPRE86IFR5cGUgdGhpcyBvbmUgcHJvcGVybHkuXHJcbiAgZnVuY3Rpb24gbm9ybWFsaXplU2xvdHMoc2xvdHMsIGN0eCkge1xyXG4gICAgICB2YXIgYWNjID0gW107XHJcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhzbG90cykucmVkdWNlKGZ1bmN0aW9uIChhcnIsIGtleSkge1xyXG4gICAgICAgICAgc2xvdHNba2V5XS5mb3JFYWNoKGZ1bmN0aW9uICh2bm9kZSkge1xyXG4gICAgICAgICAgICAgIGlmICghdm5vZGUuY29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICBzbG90c1trZXldLmNvbnRleHQgPSBjdHg7XHJcbiAgICAgICAgICAgICAgICAgIGlmICghdm5vZGUuZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdm5vZGUuZGF0YSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIHZub2RlLmRhdGEuc2xvdCA9IGtleTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHJldHVybiBhcnIuY29uY2F0KHNsb3RzW2tleV0pO1xyXG4gICAgICB9LCBhY2MpO1xyXG4gIH1cclxuICBmdW5jdGlvbiByZXNvbHZlVGV4dHVhbFJ1bGVzKHZub2RlKSB7XHJcbiAgICAgIHZhciBhdHRycyA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycztcclxuICAgICAgdmFyIHJ1bGVzID0ge307XHJcbiAgICAgIGlmICghYXR0cnMpXHJcbiAgICAgICAgICByZXR1cm4gcnVsZXM7XHJcbiAgICAgIGlmIChhdHRycy50eXBlID09PSAnZW1haWwnKSB7XHJcbiAgICAgICAgICBydWxlcy5lbWFpbCA9IFsnbXVsdGlwbGUnIGluIGF0dHJzXTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoYXR0cnMucGF0dGVybikge1xyXG4gICAgICAgICAgcnVsZXMucmVnZXggPSBhdHRycy5wYXR0ZXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChhdHRycy5tYXhsZW5ndGggPj0gMCkge1xyXG4gICAgICAgICAgcnVsZXMubWF4ID0gYXR0cnMubWF4bGVuZ3RoO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChhdHRycy5taW5sZW5ndGggPj0gMCkge1xyXG4gICAgICAgICAgcnVsZXMubWluID0gYXR0cnMubWlubGVuZ3RoO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChhdHRycy50eXBlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgaWYgKGlzU3BlY2lmaWVkKGF0dHJzLm1pbikpIHtcclxuICAgICAgICAgICAgICBydWxlcy5taW5fdmFsdWUgPSBOdW1iZXIoYXR0cnMubWluKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChpc1NwZWNpZmllZChhdHRycy5tYXgpKSB7XHJcbiAgICAgICAgICAgICAgcnVsZXMubWF4X3ZhbHVlID0gTnVtYmVyKGF0dHJzLm1heCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJ1bGVzO1xyXG4gIH1cclxuICBmdW5jdGlvbiByZXNvbHZlUnVsZXModm5vZGUpIHtcclxuICAgICAgdmFyIGh0bWxUYWdzID0gWydpbnB1dCcsICdzZWxlY3QnXTtcclxuICAgICAgdmFyIGF0dHJzID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmF0dHJzO1xyXG4gICAgICBpZiAoIWluY2x1ZGVzKGh0bWxUYWdzLCB2bm9kZS50YWcpIHx8ICFhdHRycykge1xyXG4gICAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBydWxlcyA9IHt9O1xyXG4gICAgICBpZiAoJ3JlcXVpcmVkJyBpbiBhdHRycyAmJiBhdHRycy5yZXF1aXJlZCAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgIHJ1bGVzLnJlcXVpcmVkID0gYXR0cnMudHlwZSA9PT0gJ2NoZWNrYm94JyA/IFt0cnVlXSA6IHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGlzVGV4dElucHV0KHZub2RlKSkge1xyXG4gICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVJ1bGVzKF9fYXNzaWduKF9fYXNzaWduKHt9LCBydWxlcyksIHJlc29sdmVUZXh0dWFsUnVsZXModm5vZGUpKSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5vcm1hbGl6ZVJ1bGVzKHJ1bGVzKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4oY29udGV4dCwgc2xvdFByb3BzKSB7XHJcbiAgICAgIGlmIChjb250ZXh0LiRzY29wZWRTbG90cy5kZWZhdWx0KSB7XHJcbiAgICAgICAgICByZXR1cm4gY29udGV4dC4kc2NvcGVkU2xvdHMuZGVmYXVsdChzbG90UHJvcHMpIHx8IFtdO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBjb250ZXh0LiRzbG90cy5kZWZhdWx0IHx8IFtdO1xyXG4gIH1cblxuICAvKipcclxuICAgKiBEZXRlcm1pbmVzIGlmIGEgcHJvdmlkZXIgbmVlZHMgdG8gcnVuIHZhbGlkYXRpb24uXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gc2hvdWxkVmFsaWRhdGUoY3R4LCB2YWx1ZSkge1xyXG4gICAgICAvLyB3aGVuIGFuIGltbWVkaWF0ZS9pbml0aWFsIHZhbGlkYXRpb24gaXMgbmVlZGVkIGFuZCB3YXNuJ3QgZG9uZSBiZWZvcmUuXHJcbiAgICAgIGlmICghY3R4Ll9pZ25vcmVJbW1lZGlhdGUgJiYgY3R4LmltbWVkaWF0ZSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgY2hhbmdlcyBmb3Igd2hhdGV2ZXIgcmVhc29uLlxyXG4gICAgICBpZiAoY3R4LnZhbHVlICE9PSB2YWx1ZSAmJiBjdHgubm9ybWFsaXplZEV2ZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIHdoZW4gaXQgbmVlZHMgdmFsaWRhdGlvbiBkdWUgdG8gcHJvcHMvY3Jvc3MtZmllbGRzIGNoYW5nZXMuXHJcbiAgICAgIGlmIChjdHguX25lZWRzVmFsaWRhdGlvbikge1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgLy8gd2hlbiB0aGUgaW5pdGlhbCB2YWx1ZSBpcyB1bmRlZmluZWQgYW5kIHRoZSBmaWVsZCB3YXNuJ3QgcmVuZGVyZWQgeWV0LlxyXG4gICAgICBpZiAoIWN0eC5pbml0aWFsaXplZCAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGNyZWF0ZVZhbGlkYXRpb25DdHgoY3R4KSB7XHJcbiAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY3R4LmZsYWdzKSwgeyBlcnJvcnM6IGN0eC5tZXNzYWdlcywgY2xhc3NlczogY3R4LmNsYXNzZXMsIGZhaWxlZFJ1bGVzOiBjdHguZmFpbGVkUnVsZXMsIHJlc2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjdHgucmVzZXQoKTsgfSwgdmFsaWRhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGN0eC52YWxpZGF0ZS5hcHBseShjdHgsIGFyZ3MpO1xyXG4gICAgICAgICAgfSwgYXJpYUlucHV0OiB7XHJcbiAgICAgICAgICAgICAgJ2FyaWEtaW52YWxpZCc6IGN0eC5mbGFncy5pbnZhbGlkID8gJ3RydWUnIDogJ2ZhbHNlJyxcclxuICAgICAgICAgICAgICAnYXJpYS1yZXF1aXJlZCc6IGN0eC5pc1JlcXVpcmVkID8gJ3RydWUnIDogJ2ZhbHNlJyxcclxuICAgICAgICAgICAgICAnYXJpYS1lcnJvcm1lc3NhZ2UnOiBcInZlZV9cIiArIGN0eC5pZFxyXG4gICAgICAgICAgfSwgYXJpYU1zZzoge1xyXG4gICAgICAgICAgICAgIGlkOiBcInZlZV9cIiArIGN0eC5pZCxcclxuICAgICAgICAgICAgICAnYXJpYS1saXZlJzogY3R4Lm1lc3NhZ2VzLmxlbmd0aCA/ICdhc3NlcnRpdmUnIDogJ29mZidcclxuICAgICAgICAgIH0gfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIG9uUmVuZGVyVXBkYXRlKHZtLCB2YWx1ZSkge1xyXG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghdm0uaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgIHZtLmluaXRpYWxWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciB2YWxpZGF0ZU5vdyA9IHNob3VsZFZhbGlkYXRlKHZtLCB2YWx1ZSk7XHJcbiAgICAgIHZtLl9uZWVkc1ZhbGlkYXRpb24gPSBmYWxzZTtcclxuICAgICAgdm0udmFsdWUgPSB2YWx1ZTtcclxuICAgICAgdm0uX2lnbm9yZUltbWVkaWF0ZSA9IHRydWU7XHJcbiAgICAgIGlmICghdmFsaWRhdGVOb3cpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB2bS52YWxpZGF0ZVNpbGVudCgpLnRoZW4odm0uaW1tZWRpYXRlIHx8IHZtLmZsYWdzLnZhbGlkYXRlZCA/IHZtLmFwcGx5UmVzdWx0IDogaWRlbnRpdHkpO1xyXG4gIH1cclxuICBmdW5jdGlvbiBjb21wdXRlTW9kZVNldHRpbmcoY3R4KSB7XHJcbiAgICAgIHZhciBjb21wdXRlID0gKGlzQ2FsbGFibGUoY3R4Lm1vZGUpID8gY3R4Lm1vZGUgOiBtb2Rlc1tjdHgubW9kZV0pO1xyXG4gICAgICByZXR1cm4gY29tcHV0ZSh7XHJcbiAgICAgICAgICBlcnJvcnM6IGN0eC5tZXNzYWdlcyxcclxuICAgICAgICAgIHZhbHVlOiBjdHgudmFsdWUsXHJcbiAgICAgICAgICBmbGFnczogY3R4LmZsYWdzXHJcbiAgICAgIH0pO1xyXG4gIH1cclxuICAvLyBDcmVhdGVzIHRoZSBjb21tb24gaGFuZGxlcnMgZm9yIGEgdmFsaWRhdGFibGUgY29udGV4dC5cclxuICBmdW5jdGlvbiBjcmVhdGVDb21tb25IYW5kbGVycyh2bSkge1xyXG4gICAgICBpZiAoIXZtLiR2ZWVPbklucHV0KSB7XHJcbiAgICAgICAgICB2bS4kdmVlT25JbnB1dCA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgdm0uc3luY1ZhbHVlKGUpOyAvLyB0cmFjayBhbmQga2VlcCB0aGUgdmFsdWUgdXBkYXRlZC5cclxuICAgICAgICAgICAgICB2bS5zZXRGbGFncyh7IGRpcnR5OiB0cnVlLCBwcmlzdGluZTogZmFsc2UgfSk7XHJcbiAgICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBvbklucHV0ID0gdm0uJHZlZU9uSW5wdXQ7XHJcbiAgICAgIGlmICghdm0uJHZlZU9uQmx1cikge1xyXG4gICAgICAgICAgdm0uJHZlZU9uQmx1ciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICB2bS5zZXRGbGFncyh7IHRvdWNoZWQ6IHRydWUsIHVudG91Y2hlZDogZmFsc2UgfSk7XHJcbiAgICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIC8vIEJsdXIgZXZlbnQgbGlzdGVuZXIuXHJcbiAgICAgIHZhciBvbkJsdXIgPSB2bS4kdmVlT25CbHVyO1xyXG4gICAgICB2YXIgb25WYWxpZGF0ZSA9IHZtLiR2ZWVIYW5kbGVyO1xyXG4gICAgICB2YXIgbW9kZSA9IGNvbXB1dGVNb2RlU2V0dGluZyh2bSk7XHJcbiAgICAgIC8vIEhhbmRsZSBkZWJvdW5jZSBjaGFuZ2VzLlxyXG4gICAgICBpZiAoIW9uVmFsaWRhdGUgfHwgdm0uJHZlZURlYm91bmNlICE9PSB2bS5kZWJvdW5jZSkge1xyXG4gICAgICAgICAgb25WYWxpZGF0ZSA9IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICB2bS4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICB2YXIgcGVuZGluZ1Byb21pc2UgPSB2bS52YWxpZGF0ZVNpbGVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAvLyBhdm9pZHMgcmFjZSBjb25kaXRpb25zIGJldHdlZW4gc3VjY2Vzc2l2ZSB2YWxpZGF0aW9ucy5cclxuICAgICAgICAgICAgICAgICAgdm0uX3BlbmRpbmdWYWxpZGF0aW9uID0gcGVuZGluZ1Byb21pc2U7XHJcbiAgICAgICAgICAgICAgICAgIHBlbmRpbmdQcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdQcm9taXNlID09PSB2bS5fcGVuZGluZ1ZhbGlkYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB2bS5hcHBseVJlc3VsdChyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZtLl9wZW5kaW5nVmFsaWRhdGlvbiA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9LCBtb2RlLmRlYm91bmNlIHx8IHZtLmRlYm91bmNlKTtcclxuICAgICAgICAgIC8vIENhY2hlIHRoZSBoYW5kbGVyIHNvIHdlIGRvbid0IGNyZWF0ZSBpdCBlYWNoIHRpbWUuXHJcbiAgICAgICAgICB2bS4kdmVlSGFuZGxlciA9IG9uVmFsaWRhdGU7XHJcbiAgICAgICAgICAvLyBjYWNoZSB0aGUgZGVib3VuY2UgdmFsdWUgc28gd2UgZGV0ZWN0IGlmIGl0IHdhcyBjaGFuZ2VkLlxyXG4gICAgICAgICAgdm0uJHZlZURlYm91bmNlID0gdm0uZGVib3VuY2U7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHsgb25JbnB1dDogb25JbnB1dCwgb25CbHVyOiBvbkJsdXIsIG9uVmFsaWRhdGU6IG9uVmFsaWRhdGUgfTtcclxuICB9XHJcbiAgLy8gQWRkcyBhbGwgcGx1Z2luIGxpc3RlbmVycyB0byB0aGUgdm5vZGUuXHJcbiAgZnVuY3Rpb24gYWRkTGlzdGVuZXJzKHZtLCBub2RlKSB7XHJcbiAgICAgIHZhciB2YWx1ZSA9IGZpbmRWYWx1ZShub2RlKTtcclxuICAgICAgLy8gY2FjaGUgdGhlIGlucHV0IGV2ZW50TmFtZS5cclxuICAgICAgdm0uX2lucHV0RXZlbnROYW1lID0gdm0uX2lucHV0RXZlbnROYW1lIHx8IGdldElucHV0RXZlbnROYW1lKG5vZGUsIGZpbmRNb2RlbChub2RlKSk7XHJcbiAgICAgIG9uUmVuZGVyVXBkYXRlKHZtLCB2YWx1ZSAmJiB2YWx1ZS52YWx1ZSk7XHJcbiAgICAgIHZhciBfYSA9IGNyZWF0ZUNvbW1vbkhhbmRsZXJzKHZtKSwgb25JbnB1dCA9IF9hLm9uSW5wdXQsIG9uQmx1ciA9IF9hLm9uQmx1ciwgb25WYWxpZGF0ZSA9IF9hLm9uVmFsaWRhdGU7XHJcbiAgICAgIGFkZFZOb2RlTGlzdGVuZXIobm9kZSwgdm0uX2lucHV0RXZlbnROYW1lLCBvbklucHV0KTtcclxuICAgICAgYWRkVk5vZGVMaXN0ZW5lcihub2RlLCAnYmx1cicsIG9uQmx1cik7XHJcbiAgICAgIC8vIGFkZCB0aGUgdmFsaWRhdGlvbiBsaXN0ZW5lcnMuXHJcbiAgICAgIHZtLm5vcm1hbGl6ZWRFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgICBhZGRWTm9kZUxpc3RlbmVyKG5vZGUsIGV2dCwgb25WYWxpZGF0ZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICB2bS5pbml0aWFsaXplZCA9IHRydWU7XHJcbiAgfVxuXG4gIHZhciBQUk9WSURFUl9DT1VOVEVSID0gMDtcclxuICBmdW5jdGlvbiBkYXRhKCkge1xyXG4gICAgICB2YXIgbWVzc2FnZXMgPSBbXTtcclxuICAgICAgdmFyIGRlZmF1bHRWYWx1ZXMgPSB7XHJcbiAgICAgICAgICBtZXNzYWdlczogbWVzc2FnZXMsXHJcbiAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgaW5pdGlhbGl6ZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgaW5pdGlhbFZhbHVlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICBmbGFnczogY3JlYXRlRmxhZ3MoKSxcclxuICAgICAgICAgIGZhaWxlZFJ1bGVzOiB7fSxcclxuICAgICAgICAgIGlzRGVhY3RpdmF0ZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgaWQ6ICcnXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWVzO1xyXG4gIH1cclxuICB2YXIgVmFsaWRhdGlvblByb3ZpZGVyID0gVnVlLmV4dGVuZCh7XHJcbiAgICAgIGluamVjdDoge1xyXG4gICAgICAgICAgJF92ZWVPYnNlcnZlcjoge1xyXG4gICAgICAgICAgICAgIGZyb206ICckX3ZlZU9ic2VydmVyJyxcclxuICAgICAgICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmICghdGhpcy4kdm5vZGUuY29udGV4dC4kX3ZlZU9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLiR2bm9kZS5jb250ZXh0LiRfdmVlT2JzZXJ2ZXIgPSBjcmVhdGVPYnNlcnZlcigpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiR2bm9kZS5jb250ZXh0LiRfdmVlT2JzZXJ2ZXI7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBwcm9wczoge1xyXG4gICAgICAgICAgdmlkOiB7XHJcbiAgICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG4gICAgICAgICAgICAgIGRlZmF1bHQ6ICcnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgbmFtZToge1xyXG4gICAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgbW9kZToge1xyXG4gICAgICAgICAgICAgIHR5cGU6IFtTdHJpbmcsIEZ1bmN0aW9uXSxcclxuICAgICAgICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRDb25maWcoKS5tb2RlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBydWxlczoge1xyXG4gICAgICAgICAgICAgIHR5cGU6IFtPYmplY3QsIFN0cmluZ10sXHJcbiAgICAgICAgICAgICAgZGVmYXVsdDogbnVsbFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGltbWVkaWF0ZToge1xyXG4gICAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcbiAgICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBwZXJzaXN0OiB7XHJcbiAgICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuICAgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGJhaWxzOiB7XHJcbiAgICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuICAgICAgICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBnZXRDb25maWcoKS5iYWlsczsgfVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHNraXBJZkVtcHR5OiB7XHJcbiAgICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuICAgICAgICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBnZXRDb25maWcoKS5za2lwT3B0aW9uYWw7IH1cclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkZWJvdW5jZToge1xyXG4gICAgICAgICAgICAgIHR5cGU6IE51bWJlcixcclxuICAgICAgICAgICAgICBkZWZhdWx0OiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgdGFnOiB7XHJcbiAgICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG4gICAgICAgICAgICAgIGRlZmF1bHQ6ICdzcGFuJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHNsaW06IHtcclxuICAgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG4gICAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZGlzYWJsZWQ6IHtcclxuICAgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG4gICAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgY3VzdG9tTWVzc2FnZXM6IHtcclxuICAgICAgICAgICAgICB0eXBlOiBPYmplY3QsXHJcbiAgICAgICAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICB3YXRjaDoge1xyXG4gICAgICAgICAgcnVsZXM6IHtcclxuICAgICAgICAgICAgICBkZWVwOiB0cnVlLFxyXG4gICAgICAgICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uICh2YWwsIG9sZFZhbCkge1xyXG4gICAgICAgICAgICAgICAgICB0aGlzLl9uZWVkc1ZhbGlkYXRpb24gPSAhaXNFcXVhbCh2YWwsIG9sZFZhbCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICBjb21wdXRlZDoge1xyXG4gICAgICAgICAgZmllbGREZXBzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5ub3JtYWxpemVkUnVsZXMpXHJcbiAgICAgICAgICAgICAgICAgIC5maWx0ZXIoUnVsZUNvbnRhaW5lci5pc1RhcmdldFJ1bGUpXHJcbiAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcnVsZSkge1xyXG4gICAgICAgICAgICAgICAgICB2YXIgZGVwcyA9IFJ1bGVDb250YWluZXIuZ2V0VGFyZ2V0UGFyYW1OYW1lcyhydWxlLCBfdGhpcy5ub3JtYWxpemVkUnVsZXNbcnVsZV0pO1xyXG4gICAgICAgICAgICAgICAgICBhY2MucHVzaC5hcHBseShhY2MsIGRlcHMpO1xyXG4gICAgICAgICAgICAgICAgICBkZXBzLmZvckVhY2goZnVuY3Rpb24gKGRlcE5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHdhdGNoQ3Jvc3NGaWVsZERlcChfdGhpcywgZGVwTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xyXG4gICAgICAgICAgICAgIH0sIFtdKTtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBub3JtYWxpemVkRXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICB2YXIgb24gPSBjb21wdXRlTW9kZVNldHRpbmcodGhpcykub247XHJcbiAgICAgICAgICAgICAgcmV0dXJuIChvbiB8fCBbXSkubWFwKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChlID09PSAnaW5wdXQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2lucHV0RXZlbnROYW1lO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGlzUmVxdWlyZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICB2YXIgcnVsZXMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy5fcmVzb2x2ZWRSdWxlcyksIHRoaXMubm9ybWFsaXplZFJ1bGVzKTtcclxuICAgICAgICAgICAgICB2YXIgaXNSZXF1aXJlZCA9IE9iamVjdC5rZXlzKHJ1bGVzKS5zb21lKFJ1bGVDb250YWluZXIuaXNSZXF1aXJlUnVsZSk7XHJcbiAgICAgICAgICAgICAgdGhpcy5mbGFncy5yZXF1aXJlZCA9ICEhaXNSZXF1aXJlZDtcclxuICAgICAgICAgICAgICByZXR1cm4gaXNSZXF1aXJlZDtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBjbGFzc2VzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgdmFyIG5hbWVzID0gZ2V0Q29uZmlnKCkuY2xhc3NlcztcclxuICAgICAgICAgICAgICByZXR1cm4gY29tcHV0ZUNsYXNzT2JqKG5hbWVzLCB0aGlzLmZsYWdzKTtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBub3JtYWxpemVkUnVsZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplUnVsZXModGhpcy5ydWxlcyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIHJlbmRlcjogZnVuY3Rpb24gKGgpIHtcclxuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyRmllbGQoKTtcclxuICAgICAgICAgIHZhciBjdHggPSBjcmVhdGVWYWxpZGF0aW9uQ3R4KHRoaXMpO1xyXG4gICAgICAgICAgdmFyIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4odGhpcywgY3R4KTtcclxuICAgICAgICAgIC8vIEhhbmRsZSBzaW5nbGUtcm9vdCBzbG90LlxyXG4gICAgICAgICAgZXh0cmFjdFZOb2RlcyhjaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICAgICAgICBfdGhpcy5fcmVzb2x2ZWRSdWxlcyA9IGdldENvbmZpZygpLnVzZUNvbnN0cmFpbnRBdHRycyA/IHJlc29sdmVSdWxlcyhpbnB1dCkgOiB7fTtcclxuICAgICAgICAgICAgICBhZGRMaXN0ZW5lcnMoX3RoaXMsIGlucHV0KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2xpbSAmJiBjaGlsZHJlbi5sZW5ndGggPD0gMSA/IGNoaWxkcmVuWzBdIDogaCh0aGlzLnRhZywgY2hpbGRyZW4pO1xyXG4gICAgICB9LFxyXG4gICAgICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAvLyBjbGVhbnVwIHJlZmVyZW5jZS5cclxuICAgICAgICAgIHRoaXMuJF92ZWVPYnNlcnZlci51bnN1YnNjcmliZSh0aGlzLmlkKTtcclxuICAgICAgfSxcclxuICAgICAgYWN0aXZhdGVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICB0aGlzLiRfdmVlT2JzZXJ2ZXIuc3Vic2NyaWJlKHRoaXMpO1xyXG4gICAgICAgICAgdGhpcy5pc0RlYWN0aXZhdGVkID0gZmFsc2U7XHJcbiAgICAgIH0sXHJcbiAgICAgIGRlYWN0aXZhdGVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICB0aGlzLiRfdmVlT2JzZXJ2ZXIudW5zdWJzY3JpYmUodGhpcy5pZCk7XHJcbiAgICAgICAgICB0aGlzLmlzRGVhY3RpdmF0ZWQgPSB0cnVlO1xyXG4gICAgICB9LFxyXG4gICAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgICBzZXRGbGFnczogZnVuY3Rpb24gKGZsYWdzKSB7XHJcbiAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhmbGFncykuZm9yRWFjaChmdW5jdGlvbiAoZmxhZykge1xyXG4gICAgICAgICAgICAgICAgICBfdGhpcy5mbGFnc1tmbGFnXSA9IGZsYWdzW2ZsYWddO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHN5bmNWYWx1ZTogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBub3JtYWxpemVFdmVudFZhbHVlKHYpO1xyXG4gICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICB0aGlzLmZsYWdzLmNoYW5nZWQgPSB0aGlzLmluaXRpYWxWYWx1ZSAhPT0gdmFsdWU7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2VzID0gW107XHJcbiAgICAgICAgICAgICAgdGhpcy5pbml0aWFsVmFsdWUgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgICAgICAgIHZhciBmbGFncyA9IGNyZWF0ZUZsYWdzKCk7XHJcbiAgICAgICAgICAgICAgZmxhZ3MucmVxdWlyZWQgPSB0aGlzLmlzUmVxdWlyZWQ7XHJcbiAgICAgICAgICAgICAgdGhpcy5zZXRGbGFncyhmbGFncyk7XHJcbiAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVNpbGVudCgpO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zeW5jVmFsdWUoYXJnc1swXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy52YWxpZGF0ZVNpbGVudCgpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBseVJlc3VsdChyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0XTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgdmFsaWRhdGVTaWxlbnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgIHZhciBydWxlcywgcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEZsYWdzKHsgcGVuZGluZzogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy5fcmVzb2x2ZWRSdWxlcyksIHRoaXMubm9ybWFsaXplZFJ1bGVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJ1bGVzLCAnXyQkaXNOb3JtYWxpemVkJywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHZhbGlkYXRlJHIodGhpcy52YWx1ZSwgcnVsZXMsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBjcmVhdGVWYWx1ZXNMb29rdXAodGhpcyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFpbHM6IHRoaXMuYmFpbHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcElmRW1wdHk6IHRoaXMuc2tpcElmRW1wdHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNJbml0aWFsOiAhdGhpcy5pbml0aWFsaXplZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21NZXNzYWdlczogdGhpcy5jdXN0b21NZXNzYWdlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEZsYWdzKHsgcGVuZGluZzogZmFsc2UgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0RmxhZ3MoeyB2YWxpZDogcmVzdWx0LnZhbGlkLCBpbnZhbGlkOiAhcmVzdWx0LnZhbGlkIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0XTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgc2V0RXJyb3JzOiBmdW5jdGlvbiAoZXJyb3JzKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5hcHBseVJlc3VsdCh7IGVycm9yczogZXJyb3JzLCBmYWlsZWRSdWxlczoge30gfSk7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgYXBwbHlSZXN1bHQ6IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgIHZhciBlcnJvcnMgPSBfYS5lcnJvcnMsIGZhaWxlZFJ1bGVzID0gX2EuZmFpbGVkUnVsZXM7XHJcbiAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlcyA9IGVycm9ycztcclxuICAgICAgICAgICAgICB0aGlzLmZhaWxlZFJ1bGVzID0gX19hc3NpZ24oe30sIChmYWlsZWRSdWxlcyB8fCB7fSkpO1xyXG4gICAgICAgICAgICAgIHRoaXMuc2V0RmxhZ3Moe1xyXG4gICAgICAgICAgICAgICAgICB2YWxpZDogIWVycm9ycy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgIGNoYW5nZWQ6IHRoaXMudmFsdWUgIT09IHRoaXMuaW5pdGlhbFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICBpbnZhbGlkOiAhIWVycm9ycy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgIHZhbGlkYXRlZDogdHJ1ZVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHJlZ2lzdGVyRmllbGQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICB1cGRhdGVSZW5kZXJpbmdDb250ZXh0UmVmcyh0aGlzKTtcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gIH0pO1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZVZhbHVlc0xvb2t1cCh2bSkge1xyXG4gICAgICB2YXIgcHJvdmlkZXJzID0gdm0uJF92ZWVPYnNlcnZlci5yZWZzO1xyXG4gICAgICB2YXIgcmVkdWNlZCA9IHt9O1xyXG4gICAgICByZXR1cm4gdm0uZmllbGREZXBzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBkZXBOYW1lKSB7XHJcbiAgICAgICAgICBpZiAoIXByb3ZpZGVyc1tkZXBOYW1lXSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBhY2M7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBhY2NbZGVwTmFtZV0gPSBwcm92aWRlcnNbZGVwTmFtZV0udmFsdWU7XHJcbiAgICAgICAgICByZXR1cm4gYWNjO1xyXG4gICAgICB9LCByZWR1Y2VkKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gZXh0cmFjdElkKHZtKSB7XHJcbiAgICAgIGlmICh2bS52aWQpIHtcclxuICAgICAgICAgIHJldHVybiB2bS52aWQ7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHZtLm5hbWUpIHtcclxuICAgICAgICAgIHJldHVybiB2bS5uYW1lO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh2bS5pZCkge1xyXG4gICAgICAgICAgcmV0dXJuIHZtLmlkO1xyXG4gICAgICB9XHJcbiAgICAgIFBST1ZJREVSX0NPVU5URVIrKztcclxuICAgICAgcmV0dXJuIFwiX3ZlZV9cIiArIFBST1ZJREVSX0NPVU5URVI7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHVwZGF0ZVJlbmRlcmluZ0NvbnRleHRSZWZzKHZtKSB7XHJcbiAgICAgIHZhciBwcm92aWRlZElkID0gZXh0cmFjdElkKHZtKTtcclxuICAgICAgdmFyIGlkID0gdm0uaWQ7XHJcbiAgICAgIC8vIE5vdGhpbmcgaGFzIGNoYW5nZWQuXHJcbiAgICAgIGlmICh2bS5pc0RlYWN0aXZhdGVkIHx8IChpZCA9PT0gcHJvdmlkZWRJZCAmJiB2bS4kX3ZlZU9ic2VydmVyLnJlZnNbaWRdKSkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIHZpZCB3YXMgY2hhbmdlZC5cclxuICAgICAgaWYgKGlkICE9PSBwcm92aWRlZElkICYmIHZtLiRfdmVlT2JzZXJ2ZXIucmVmc1tpZF0gPT09IHZtKSB7XHJcbiAgICAgICAgICB2bS4kX3ZlZU9ic2VydmVyLnVuc3Vic2NyaWJlKGlkKTtcclxuICAgICAgfVxyXG4gICAgICB2bS5pZCA9IHByb3ZpZGVkSWQ7XHJcbiAgICAgIHZtLiRfdmVlT2JzZXJ2ZXIuc3Vic2NyaWJlKHZtKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gY3JlYXRlT2JzZXJ2ZXIoKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICByZWZzOiB7fSxcclxuICAgICAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24gKHZtKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5yZWZzW3ZtLmlkXSA9IHZtO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5yZWZzW2lkXTtcclxuICAgICAgICAgIH1cclxuICAgICAgfTtcclxuICB9XHJcbiAgZnVuY3Rpb24gd2F0Y2hDcm9zc0ZpZWxkRGVwKGN0eCwgZGVwTmFtZSwgd2l0aEhvb2tzKSB7XHJcbiAgICAgIGlmICh3aXRoSG9va3MgPT09IHZvaWQgMCkgeyB3aXRoSG9va3MgPSB0cnVlOyB9XHJcbiAgICAgIHZhciBwcm92aWRlcnMgPSBjdHguJF92ZWVPYnNlcnZlci5yZWZzO1xyXG4gICAgICBpZiAoIWN0eC5fdmVlV2F0Y2hlcnMpIHtcclxuICAgICAgICAgIGN0eC5fdmVlV2F0Y2hlcnMgPSB7fTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIXByb3ZpZGVyc1tkZXBOYW1lXSAmJiB3aXRoSG9va3MpIHtcclxuICAgICAgICAgIHJldHVybiBjdHguJG9uY2UoJ2hvb2s6bW91bnRlZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICB3YXRjaENyb3NzRmllbGREZXAoY3R4LCBkZXBOYW1lLCBmYWxzZSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWlzQ2FsbGFibGUoY3R4Ll92ZWVXYXRjaGVyc1tkZXBOYW1lXSkgJiYgcHJvdmlkZXJzW2RlcE5hbWVdKSB7XHJcbiAgICAgICAgICBjdHguX3ZlZVdhdGNoZXJzW2RlcE5hbWVdID0gcHJvdmlkZXJzW2RlcE5hbWVdLiR3YXRjaCgndmFsdWUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGN0eC5mbGFncy52YWxpZGF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgY3R4Ll9uZWVkc1ZhbGlkYXRpb24gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICBjdHgudmFsaWRhdGUoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gIH1cblxuICB2YXIgZmxhZ01lcmdpbmdTdHJhdGVneSA9IHtcclxuICAgICAgcHJpc3RpbmU6ICdldmVyeScsXHJcbiAgICAgIGRpcnR5OiAnc29tZScsXHJcbiAgICAgIHRvdWNoZWQ6ICdzb21lJyxcclxuICAgICAgdW50b3VjaGVkOiAnZXZlcnknLFxyXG4gICAgICB2YWxpZDogJ2V2ZXJ5JyxcclxuICAgICAgaW52YWxpZDogJ3NvbWUnLFxyXG4gICAgICBwZW5kaW5nOiAnc29tZScsXHJcbiAgICAgIHZhbGlkYXRlZDogJ2V2ZXJ5JyxcclxuICAgICAgY2hhbmdlZDogJ3NvbWUnXHJcbiAgfTtcclxuICBmdW5jdGlvbiBtZXJnZUZsYWdzKGxocywgcmhzLCBzdHJhdGVneSkge1xyXG4gICAgICB2YXIgc3RyYXROYW1lID0gZmxhZ01lcmdpbmdTdHJhdGVneVtzdHJhdGVneV07XHJcbiAgICAgIHJldHVybiBbbGhzLCByaHNdW3N0cmF0TmFtZV0oZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGY7IH0pO1xyXG4gIH1cclxuICB2YXIgT0JTRVJWRVJfQ09VTlRFUiA9IDA7XHJcbiAgZnVuY3Rpb24gZGF0YSQxKCkge1xyXG4gICAgICB2YXIgcmVmcyA9IHt9O1xyXG4gICAgICB2YXIgcmVmc0J5TmFtZSA9IHt9O1xyXG4gICAgICB2YXIgaW5hY3RpdmVSZWZzID0ge307XHJcbiAgICAgIC8vIEZJWE1FOiBOb3Qgc3VyZSBvZiB0aGlzIG9uZSBjYW4gYmUgdHlwZWQsIGNpcmN1bGFyIHR5cGUgcmVmZXJlbmNlLlxyXG4gICAgICB2YXIgb2JzZXJ2ZXJzID0gW107XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBpZDogJycsXHJcbiAgICAgICAgICByZWZzOiByZWZzLFxyXG4gICAgICAgICAgcmVmc0J5TmFtZTogcmVmc0J5TmFtZSxcclxuICAgICAgICAgIG9ic2VydmVyczogb2JzZXJ2ZXJzLFxyXG4gICAgICAgICAgaW5hY3RpdmVSZWZzOiBpbmFjdGl2ZVJlZnNcclxuICAgICAgfTtcclxuICB9XHJcbiAgdmFyIFZhbGlkYXRpb25PYnNlcnZlciA9IFZ1ZS5leHRlbmQoe1xyXG4gICAgICBuYW1lOiAnVmFsaWRhdGlvbk9ic2VydmVyJyxcclxuICAgICAgcHJvdmlkZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAkX3ZlZU9ic2VydmVyOiB0aGlzXHJcbiAgICAgICAgICB9O1xyXG4gICAgICB9LFxyXG4gICAgICBpbmplY3Q6IHtcclxuICAgICAgICAgICRfdmVlT2JzZXJ2ZXI6IHtcclxuICAgICAgICAgICAgICBmcm9tOiAnJF92ZWVPYnNlcnZlcicsXHJcbiAgICAgICAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuJHZub2RlLmNvbnRleHQuJF92ZWVPYnNlcnZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHZub2RlLmNvbnRleHQuJF92ZWVPYnNlcnZlcjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIHByb3BzOiB7XHJcbiAgICAgICAgICB0YWc6IHtcclxuICAgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICAgICAgICAgICAgZGVmYXVsdDogJ3NwYW4nXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgdmlkOiB7XHJcbiAgICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG4gICAgICAgICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwib2JzX1wiICsgT0JTRVJWRVJfQ09VTlRFUisrO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBzbGltOiB7XHJcbiAgICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuICAgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGRpc2FibGVkOiB7XHJcbiAgICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuICAgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG4gICAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBkYXRhOiBkYXRhJDEsXHJcbiAgICAgIGNvbXB1dGVkOiB7XHJcbiAgICAgICAgICBjdHg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgIHZhciBjdHggPSB7XHJcbiAgICAgICAgICAgICAgICAgIGVycm9yczoge30sXHJcbiAgICAgICAgICAgICAgICAgIHBhc3NlczogZnVuY3Rpb24gKGNiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMudmFsaWRhdGUoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnZhbGlkYXRlLmFwcGx5KF90aGlzLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnJlc2V0KCk7IH1cclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5cyh2YWx1ZXModGhpcy5yZWZzKSwgT2JqZWN0LmtleXModGhpcy5pbmFjdGl2ZVJlZnMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICB2aWQ6IGtleSxcclxuICAgICAgICAgICAgICAgICAgICAgIGZsYWdzOiBfdGhpcy5pbmFjdGl2ZVJlZnNba2V5XS5mbGFncyxcclxuICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiBfdGhpcy5pbmFjdGl2ZVJlZnNba2V5XS5lcnJvcnNcclxuICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICB9KSwgdGhpcy5vYnNlcnZlcnMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwcm92aWRlcikge1xyXG4gICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhmbGFnTWVyZ2luZ1N0cmF0ZWd5KS5mb3JFYWNoKGZ1bmN0aW9uIChmbGFnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZmxhZ3MgPSBwcm92aWRlci5mbGFncyB8fCBwcm92aWRlci5jdHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIShmbGFnIGluIGFjYykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NbZmxhZ10gPSBmbGFnc1tmbGFnXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICBhY2NbZmxhZ10gPSBtZXJnZUZsYWdzKGFjY1tmbGFnXSwgZmxhZ3NbZmxhZ10sIGZsYWcpO1xyXG4gICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgYWNjLmVycm9yc1twcm92aWRlci5pZF0gPVxyXG4gICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIubWVzc2FnZXMgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMocHJvdmlkZXIuY3R4LmVycm9ycykucmVkdWNlKGZ1bmN0aW9uIChlcnJzLCBvYnNFcnJvcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycnMuY29uY2F0KG9ic0Vycm9ycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10pO1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xyXG4gICAgICAgICAgICAgIH0sIGN0eCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHRoaXMuaWQgPSB0aGlzLnZpZDtcclxuICAgICAgICAgIGlmICh0aGlzLiRfdmVlT2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgICB0aGlzLiRfdmVlT2JzZXJ2ZXIuc3Vic2NyaWJlKHRoaXMsICdvYnNlcnZlcicpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBhY3RpdmF0ZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGlmICh0aGlzLiRfdmVlT2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgICB0aGlzLiRfdmVlT2JzZXJ2ZXIuc3Vic2NyaWJlKHRoaXMsICdvYnNlcnZlcicpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBkZWFjdGl2YXRlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgaWYgKHRoaXMuJF92ZWVPYnNlcnZlcikge1xyXG4gICAgICAgICAgICAgIHRoaXMuJF92ZWVPYnNlcnZlci51bnN1YnNjcmliZSh0aGlzLmlkLCAnb2JzZXJ2ZXInKTtcclxuICAgICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgaWYgKHRoaXMuJF92ZWVPYnNlcnZlcikge1xyXG4gICAgICAgICAgICAgIHRoaXMuJF92ZWVPYnNlcnZlci51bnN1YnNjcmliZSh0aGlzLmlkLCAnb2JzZXJ2ZXInKTtcclxuICAgICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoaCkge1xyXG4gICAgICAgICAgdmFyIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4odGhpcywgdGhpcy5jdHgpO1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2xpbSAmJiBjaGlsZHJlbi5sZW5ndGggPD0gMSA/IGNoaWxkcmVuWzBdIDogaCh0aGlzLnRhZywgeyBvbjogdGhpcy4kbGlzdGVuZXJzIH0sIGNoaWxkcmVuKTtcclxuICAgICAgfSxcclxuICAgICAgbWV0aG9kczoge1xyXG4gICAgICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiAoc3Vic2NyaWJlciwga2luZCkge1xyXG4gICAgICAgICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgICAgICAgaWYgKGtpbmQgPT09IHZvaWQgMCkgeyBraW5kID0gJ3Byb3ZpZGVyJzsgfVxyXG4gICAgICAgICAgICAgIGlmIChraW5kID09PSAnb2JzZXJ2ZXInKSB7XHJcbiAgICAgICAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2goc3Vic2NyaWJlcik7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgdGhpcy5yZWZzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMucmVmcyksIChfYSA9IHt9LCBfYVtzdWJzY3JpYmVyLmlkXSA9IHN1YnNjcmliZXIsIF9hKSk7XHJcbiAgICAgICAgICAgICAgdGhpcy5yZWZzQnlOYW1lID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMucmVmc0J5TmFtZSksIChfYiA9IHt9LCBfYltzdWJzY3JpYmVyLm5hbWVdID0gc3Vic2NyaWJlciwgX2IpKTtcclxuICAgICAgICAgICAgICBpZiAoc3Vic2NyaWJlci5wZXJzaXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgIHRoaXMucmVzdG9yZVByb3ZpZGVyU3RhdGUoc3Vic2NyaWJlcik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiAoaWQsIGtpbmQpIHtcclxuICAgICAgICAgICAgICBpZiAoa2luZCA9PT0gdm9pZCAwKSB7IGtpbmQgPSAncHJvdmlkZXInOyB9XHJcbiAgICAgICAgICAgICAgaWYgKGtpbmQgPT09ICdwcm92aWRlcicpIHtcclxuICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVQcm92aWRlcihpZCk7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgdmFyIGlkeCA9IGZpbmRJbmRleCh0aGlzLm9ic2VydmVycywgZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8uaWQgPT09IGlkOyB9KTtcclxuICAgICAgICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmVycy5zcGxpY2UoaWR4LCAxKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgIHZhciBfYiA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkuc2lsZW50LCBzaWxlbnQgPSBfYiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYjtcclxuICAgICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRzO1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLmFsbChfX3NwcmVhZEFycmF5cyh2YWx1ZXModGhpcy5yZWZzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gIXIuZGlzYWJsZWQ7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChyZWYpIHsgcmV0dXJuIHJlZltzaWxlbnQgPyAndmFsaWRhdGVTaWxlbnQnIDogJ3ZhbGlkYXRlJ10oKS50aGVuKGZ1bmN0aW9uIChyKSB7IHJldHVybiByLnZhbGlkOyB9KTsgfSksIHRoaXMub2JzZXJ2ZXJzLmZpbHRlcihmdW5jdGlvbiAobykgeyByZXR1cm4gIW8uZGlzYWJsZWQ7IH0pLm1hcChmdW5jdGlvbiAob2JzKSB7IHJldHVybiBvYnMudmFsaWRhdGUoeyBzaWxlbnQ6IHNpbGVudCB9KTsgfSkpKV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0cy5ldmVyeShmdW5jdGlvbiAocikgeyByZXR1cm4gcjsgfSldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5pbmFjdGl2ZVJlZnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICAgICAgICBfdGhpcy4kZGVsZXRlKF90aGlzLmluYWN0aXZlUmVmcywga2V5KTtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheXModmFsdWVzKHRoaXMucmVmcyksIHRoaXMub2JzZXJ2ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHsgcmV0dXJuIHJlZi5yZXNldCgpOyB9KTtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICByZXN0b3JlUHJvdmlkZXJTdGF0ZTogZnVuY3Rpb24gKHByb3ZpZGVyKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGlkID0gcHJvdmlkZXIuaWQ7XHJcbiAgICAgICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5pbmFjdGl2ZVJlZnNbaWRdO1xyXG4gICAgICAgICAgICAgIGlmICghc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBwcm92aWRlci5zZXRGbGFncyhzdGF0ZS5mbGFncyk7XHJcbiAgICAgICAgICAgICAgcHJvdmlkZXIuYXBwbHlSZXN1bHQoc3RhdGUpO1xyXG4gICAgICAgICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLmluYWN0aXZlUmVmcywgcHJvdmlkZXIuaWQpO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHJlbW92ZVByb3ZpZGVyOiBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICAgICAgICB2YXIgcHJvdmlkZXIgPSB0aGlzLnJlZnNbaWRdO1xyXG4gICAgICAgICAgICAgIGlmICghcHJvdmlkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IGluYWN0aXZlIHJlZnMgYXJlIG5vdCBiZWluZyBjbGVhbmVkIHVwLlxyXG4gICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmIChwcm92aWRlci5wZXJzaXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgIC8vIHNhdmUgaXQgZm9yIHRoZSBuZXh0IHRpbWUuXHJcbiAgICAgICAgICAgICAgICAgIHRoaXMuaW5hY3RpdmVSZWZzW2lkXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgIGZsYWdzOiBwcm92aWRlci5mbGFncyxcclxuICAgICAgICAgICAgICAgICAgICAgIGVycm9yczogcHJvdmlkZXIubWVzc2FnZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICBmYWlsZWRSdWxlczogcHJvdmlkZXIuZmFpbGVkUnVsZXNcclxuICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgdGhpcy4kZGVsZXRlKHRoaXMucmVmcywgaWQpO1xyXG4gICAgICAgICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLnJlZnNCeU5hbWUsIHByb3ZpZGVyLm5hbWUpO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHNldEVycm9yczogZnVuY3Rpb24gKGVycm9ycykge1xyXG4gICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZXJyb3JzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgdmFyIHByb3ZpZGVyID0gX3RoaXMucmVmc1trZXldIHx8IF90aGlzLnJlZnNCeU5hbWVba2V5XTtcclxuICAgICAgICAgICAgICAgICAgaWYgKCFwcm92aWRlcilcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXIuc2V0RXJyb3JzKGVycm9yc1trZXldIHx8IFtdKTtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB0aGlzLm9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgICAgICAgICAgICBvYnNlcnZlci5zZXRFcnJvcnMoZXJyb3JzKTtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHdpdGhWYWxpZGF0aW9uKGNvbXBvbmVudCwgbWFwUHJvcHMpIHtcclxuICAgICAgaWYgKG1hcFByb3BzID09PSB2b2lkIDApIHsgbWFwUHJvcHMgPSBpZGVudGl0eTsgfVxyXG4gICAgICB2YXIgb3B0aW9ucyA9ICdvcHRpb25zJyBpbiBjb21wb25lbnQgPyBjb21wb25lbnQub3B0aW9ucyA6IGNvbXBvbmVudDtcclxuICAgICAgdmFyIHByb3ZpZGVyT3B0cyA9IFZhbGlkYXRpb25Qcm92aWRlci5vcHRpb25zO1xyXG4gICAgICB2YXIgaG9jID0ge1xyXG4gICAgICAgICAgbmFtZTogKG9wdGlvbnMubmFtZSB8fCAnQW5vbnltb3VzSG9jJykgKyBcIldpdGhWYWxpZGF0aW9uXCIsXHJcbiAgICAgICAgICBwcm9wczogX19hc3NpZ24oe30sIHByb3ZpZGVyT3B0cy5wcm9wcyksXHJcbiAgICAgICAgICBkYXRhOiBwcm92aWRlck9wdHMuZGF0YSxcclxuICAgICAgICAgIGNvbXB1dGVkOiBfX2Fzc2lnbih7fSwgcHJvdmlkZXJPcHRzLmNvbXB1dGVkKSxcclxuICAgICAgICAgIG1ldGhvZHM6IF9fYXNzaWduKHt9LCBwcm92aWRlck9wdHMubWV0aG9kcyksXHJcbiAgICAgICAgICBiZWZvcmVEZXN0cm95OiBwcm92aWRlck9wdHMuYmVmb3JlRGVzdHJveSxcclxuICAgICAgICAgIGluamVjdDogcHJvdmlkZXJPcHRzLmluamVjdFxyXG4gICAgICB9O1xyXG4gICAgICB2YXIgZXZlbnROYW1lID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0JztcclxuICAgICAgaG9jLnJlbmRlciA9IGZ1bmN0aW9uIChoKSB7XHJcbiAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyRmllbGQoKTtcclxuICAgICAgICAgIHZhciB2Y3R4ID0gY3JlYXRlVmFsaWRhdGlvbkN0eCh0aGlzKTtcclxuICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSBfX2Fzc2lnbih7fSwgdGhpcy4kbGlzdGVuZXJzKTtcclxuICAgICAgICAgIHZhciBtb2RlbCA9IGZpbmRNb2RlbCh0aGlzLiR2bm9kZSk7XHJcbiAgICAgICAgICB0aGlzLl9pbnB1dEV2ZW50TmFtZSA9IHRoaXMuX2lucHV0RXZlbnROYW1lIHx8IGdldElucHV0RXZlbnROYW1lKHRoaXMuJHZub2RlLCBtb2RlbCk7XHJcbiAgICAgICAgICB2YXIgdmFsdWUgPSBmaW5kVmFsdWUodGhpcy4kdm5vZGUpO1xyXG4gICAgICAgICAgb25SZW5kZXJVcGRhdGUodGhpcywgdmFsdWUgJiYgdmFsdWUudmFsdWUpO1xyXG4gICAgICAgICAgdmFyIF9iID0gY3JlYXRlQ29tbW9uSGFuZGxlcnModGhpcyksIG9uSW5wdXQgPSBfYi5vbklucHV0LCBvbkJsdXIgPSBfYi5vbkJsdXIsIG9uVmFsaWRhdGUgPSBfYi5vblZhbGlkYXRlO1xyXG4gICAgICAgICAgbWVyZ2VWTm9kZUxpc3RlbmVycyhsaXN0ZW5lcnMsIGV2ZW50TmFtZSwgb25JbnB1dCk7XHJcbiAgICAgICAgICBtZXJnZVZOb2RlTGlzdGVuZXJzKGxpc3RlbmVycywgJ2JsdXInLCBvbkJsdXIpO1xyXG4gICAgICAgICAgdGhpcy5ub3JtYWxpemVkRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgICAgICAgIG1lcmdlVk5vZGVMaXN0ZW5lcnMobGlzdGVuZXJzLCBldnQsIG9uVmFsaWRhdGUpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICAvLyBQcm9wcyBhcmUgYW55IGF0dHJzIG5vdCBhc3NvY2lhdGVkIHdpdGggVmFsaWRhdGlvblByb3ZpZGVyIFBsdXMgdGhlIG1vZGVsIHByb3AuXHJcbiAgICAgICAgICAvLyBXQVJOSU5HOiBBY2NpZGVudGFsIHByb3Agb3ZlcndyaXRlIHdpbGwgcHJvYmFibHkgaGFwcGVuLlxyXG4gICAgICAgICAgdmFyIHByb3AgPSAoZmluZE1vZGVsQ29uZmlnKHRoaXMuJHZub2RlKSB8fCB7IHByb3A6ICd2YWx1ZScgfSkucHJvcDtcclxuICAgICAgICAgIHZhciBwcm9wcyA9IF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLiRhdHRycyksIChfYSA9IHt9LCBfYVtwcm9wXSA9IG1vZGVsICYmIG1vZGVsLnZhbHVlLCBfYSkpLCBtYXBQcm9wcyh2Y3R4KSk7XHJcbiAgICAgICAgICByZXR1cm4gaChvcHRpb25zLCB7XHJcbiAgICAgICAgICAgICAgYXR0cnM6IHRoaXMuJGF0dHJzLFxyXG4gICAgICAgICAgICAgIHByb3BzOiBwcm9wcyxcclxuICAgICAgICAgICAgICBvbjogbGlzdGVuZXJzXHJcbiAgICAgICAgICB9LCBub3JtYWxpemVTbG90cyh0aGlzLiRzbG90cywgdGhpcy4kdm5vZGUuY29udGV4dCkpO1xyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gaG9jO1xyXG4gIH1cblxuICB2YXIgdmVyc2lvbiA9ICczLjAuOCc7XHJcbiAgLy8gSW5zdGFsbCBhbGwgcnVsZXMuXHJcbiAgdmFyIFJ1bGVzQXNMaXN0ID0gT2JqZWN0LmtleXMoUnVsZXMpLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAoeyBzY2hlbWE6IFJ1bGVzW2tleV0sIG5hbWU6IGtleSB9KTsgfSk7XHJcbiAgUnVsZXNBc0xpc3QuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgdmFyIG5hbWUgPSBfYS5uYW1lLCBzY2hlbWEgPSBfYS5zY2hlbWE7XHJcbiAgICAgIGV4dGVuZChuYW1lLCBzY2hlbWEpO1xyXG4gIH0pO1xyXG4gIC8vIEluc3RhbGwgbG9jYWxlXHJcbiAgbG9jYWxpemUoJ2VuJywgZW4pO1xuXG4gIGV4cG9ydHMuUnVsZXMgPSBSdWxlcztcbiAgZXhwb3J0cy5WYWxpZGF0aW9uT2JzZXJ2ZXIgPSBWYWxpZGF0aW9uT2JzZXJ2ZXI7XG4gIGV4cG9ydHMuVmFsaWRhdGlvblByb3ZpZGVyID0gVmFsaWRhdGlvblByb3ZpZGVyO1xuICBleHBvcnRzLmNvbmZpZ3VyZSA9IGNvbmZpZ3VyZTtcbiAgZXhwb3J0cy5leHRlbmQgPSBleHRlbmQ7XG4gIGV4cG9ydHMuaW5zdGFsbCA9IGluc3RhbGw7XG4gIGV4cG9ydHMubG9jYWxpemUgPSBsb2NhbGl6ZTtcbiAgZXhwb3J0cy5zZXRJbnRlcmFjdGlvbk1vZGUgPSBzZXRJbnRlcmFjdGlvbk1vZGU7XG4gIGV4cG9ydHMudmFsaWRhdGUgPSB2YWxpZGF0ZSRyO1xuICBleHBvcnRzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICBleHBvcnRzLndpdGhWYWxpZGF0aW9uID0gd2l0aFZhbGlkYXRpb247XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vee-validate/dist/vee-validate.full.js\n");

/***/ })

}]);